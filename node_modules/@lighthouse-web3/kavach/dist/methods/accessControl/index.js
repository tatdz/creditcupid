"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessControl = void 0;
const config_1 = __importDefault(require("../../config"));
const validator_1 = require("./validator");
const index_1 = require("../../util/index");
const accessControl = async (address, cid, auth_token, conditions, aggregator, chainType = "evm", keyShards = [], decryptionType = "ADDRESS") => {
    try {
        if (!Array.isArray(keyShards) ||
            (keyShards.length != 5 && keyShards.length != 0)) {
            throw new Error("keyShards must be an array of 5 objects");
        }
        if (!(0, index_1.isCidReg)(cid)) {
            throw new Error("Invalid CID");
        }
        const { error } = keyShards.length == 5
            ? validator_1.accessConditionSchema.validate({
                address,
                cid,
                conditions,
                aggregator,
                decryptionType,
                chainType,
                keyShards,
            })
            : validator_1.updateConditionSchema.validate({
                address,
                cid,
                conditions,
                aggregator,
                chainType,
            });
        if (error) {
            throw new Error(`Condition validation error: ${error.message}`);
        }
        const nodeId = [1, 2, 3, 4, 5];
        const nodeUrl = nodeId.map((elem) => config_1.default.isDev
            ? `:900${elem}/api/fileAccessConditions/${elem}`
            : `/api/fileAccessConditions/${elem}`);
        // send encryption key
        const requestData = async (url, index) => {
            try {
                return keyShards.length === 5
                    ? await (0, index_1.API_NODE_HANDLER)(url, "POST", auth_token, {
                        address,
                        cid,
                        conditions,
                        aggregator,
                        decryptionType,
                        chainType,
                        payload: keyShards[index],
                    })
                    : await (0, index_1.API_NODE_HANDLER)(url, "PUT", auth_token, {
                        address,
                        cid,
                        conditions,
                        aggregator,
                        chainType,
                    });
            }
            catch (error) {
                return {
                    isSuccess: false,
                    error: JSON.parse(error.message),
                };
            }
        };
        const data = [];
        for (const [index, url] of nodeUrl.entries()) {
            const response = await requestData(url, index);
            if (response.error)
                await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before retrying
            data.push(response);
        }
        return {
            isSuccess: (0, index_1.isEqual)(...data.map((e) => e.message)) &&
                data[0]?.message === "success",
            error: null,
        };
    }
    catch (err) {
        return { isSuccess: false, error: JSON.parse(err?.message) };
    }
};
exports.accessControl = accessControl;
