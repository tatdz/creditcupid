"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessConditionSchema = exports.updateConditionSchema = void 0;
const joi_1 = __importDefault(require("joi"));
const solidityType = [
    "address",
    "address[]",
    "bool",
    "bool[]",
    "bytes1",
    "bytes2",
    "bytes3",
    "bytes4",
    "bytes5",
    "bytes6",
    "bytes7",
    "bytes8",
    "bytes16",
    "bytes32",
    "bytes1[]",
    "bytes2[]",
    "bytes3[]",
    "bytes4[]",
    "bytes5[]",
    "bytes6[]",
    "bytes7[]",
    "bytes8[]",
    "bytes16[]",
    "bytes32[]",
    "uint8",
    "uint16",
    "uint24",
    "uint32",
    "uint40",
    "uint48",
    "uint64",
    "uint128",
    "uint192",
    "uint256",
    "int8",
    "int16",
    "int24",
    "int32",
    "int40",
    "int48",
    "int64",
    "int128",
    "int192",
    "int256",
    "uint8[]",
    "uint16[]",
    "uint24[]",
    "uint32[]",
    "uint40[]",
    "uint48[]",
    "uint64[]",
    "uint128[]",
    "uint192[]",
    "uint256[]",
    "int8[]",
    "int16[]",
    "int24[]",
    "int32[]",
    "int40[]",
    "int48[]",
    "int64[]",
    "int128[]",
    "int192[]",
    "int256[]",
];
const SupportedChains = {
    EVM: [],
    SOLANA: ["DEVNET", "TESTNET", "MAINNET"],
    COREUM: ["Coreum_Devnet", "Coreum_Testnet", "Coreum_Mainnet"],
};
const evmConditions = joi_1.default.array()
    .min(1)
    .required()
    .items(joi_1.default.object({
    id: joi_1.default.number().min(1).required(),
    standardContractType: joi_1.default.string()
        .valid("ERC20", "ERC721", "ERC1155", "Custom", "")
        .insensitive()
        .required(),
    contractAddress: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string(),
        otherwise: joi_1.default.string().required(),
    }),
    chain: joi_1.default.string().insensitive().required(),
    method: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string().valid("getBalance", "getBlockNumber").required(),
        otherwise: joi_1.default.string().required(),
    }),
    parameters: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.array(),
        otherwise: joi_1.default.array().required(),
    }),
    returnValueTest: joi_1.default.object({
        comparator: joi_1.default.string()
            .valid("==", ">=", "<=", "!=", ">", "<")
            .required(),
        value: joi_1.default.alternatives(joi_1.default.number(), joi_1.default.string(), joi_1.default.array()).required(),
    }).required(),
    inputArrayType: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal("Custom"),
        then: joi_1.default.array()
            .items(joi_1.default.string().valid(...solidityType))
            .required(),
    }),
    outputType: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal("Custom"),
        then: joi_1.default.string()
            .valid(...solidityType)
            .required(),
    }),
}))
    .unique((a, b) => a.id === b.id);
const solanaConditions = joi_1.default.array()
    .min(1)
    .required()
    .items(joi_1.default.object({
    id: joi_1.default.number().min(1).required(),
    contractAddress: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string(),
        otherwise: joi_1.default.string().required(),
    }),
    chain: joi_1.default.string()
        .valid(...SupportedChains["SOLANA"])
        .insensitive()
        .required(),
    method: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string()
            .valid("getBalance", "getLastBlockTime", "getBlockHeight")
            .required(),
        otherwise: joi_1.default.string().valid("getTokenAccountsByOwner").required(),
    }),
    standardContractType: joi_1.default.string()
        .valid("spl-token", "")
        .insensitive()
        .required(),
    parameters: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.array(),
        otherwise: joi_1.default.array(),
    }),
    pdaInterface: joi_1.default.object({
        offset: joi_1.default.number().min(0),
        selector: joi_1.default.string(),
    }).required(),
    returnValueTest: joi_1.default.object({
        comparator: joi_1.default.string()
            .valid("==", ">=", "<=", "!=", ">", "<")
            .required(),
        value: joi_1.default.alternatives(joi_1.default.number(), joi_1.default.string(), joi_1.default.array()).required(),
    }).required(),
}))
    .unique((a, b) => a.id === b.id);
const coreumConditions = joi_1.default.array()
    .min(1)
    .required()
    .items(joi_1.default.object({
    id: joi_1.default.number().min(1).required(),
    contractAddress: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string(),
        otherwise: joi_1.default.string().required(),
    }),
    denom: joi_1.default.string(),
    classid: joi_1.default.string(),
    standardContractType: joi_1.default.string().allow(""),
    chain: joi_1.default.string()
        .valid(...SupportedChains["COREUM"])
        .insensitive()
        .required(),
    method: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.string().required(),
        otherwise: joi_1.default.string().required(),
    }),
    parameters: joi_1.default.when("standardContractType", {
        is: joi_1.default.equal(""),
        then: joi_1.default.array(),
        otherwise: joi_1.default.array().required(),
    }),
    returnValueTest: joi_1.default.object({
        comparator: joi_1.default.string()
            .valid("==", ">=", "<=", "!=", ">", "<")
            .required(),
        value: joi_1.default.alternatives(joi_1.default.number(), joi_1.default.string(), joi_1.default.array()).required(),
    }).required(),
}))
    .unique((a, b) => a.id === b.id);
const updateConditionSchema = joi_1.default.object({
    chainType: joi_1.default.string()
        .allow("", null)
        .empty(["", null])
        .default("EVM")
        .valid("EVM", "SOLANA", "COREUM")
        .insensitive(),
    conditions: joi_1.default.when("chainType", {
        is: joi_1.default.equal("EVM"),
        then: evmConditions,
        otherwise: joi_1.default.when("chainType", {
            is: joi_1.default.equal("SOLANA"),
            then: solanaConditions,
            otherwise: coreumConditions,
        }),
    }),
    decryptionType: joi_1.default.string()
        .allow("", null)
        .empty(["", null])
        .default("ADDRESS")
        .valid("ADDRESS", "ACCESS_CONDITIONS")
        .insensitive(),
    address: joi_1.default.string().required(),
    cid: joi_1.default.string().required(),
    // TO aggregator next iteration: "1 or 2 and (3 xor 4)"
    aggregator: joi_1.default.when("conditions.length", {
        is: joi_1.default.number().greater(1),
        then: joi_1.default.string()
            .pattern(/( and | or )/i)
            .required(),
    }),
});
exports.updateConditionSchema = updateConditionSchema;
const accessConditionSchema = joi_1.default.object({
    chainType: joi_1.default.string()
        .allow("", null)
        .empty(["", null])
        .default("EVM")
        .valid("EVM", "SOLANA", "COREUM")
        .insensitive(),
    decryptionType: joi_1.default.string()
        .allow("", null)
        .empty(["", null])
        .default("ADDRESS")
        .valid("ADDRESS", "ACCESS_CONDITIONS")
        .insensitive(),
    conditions: joi_1.default.when("chainType", {
        is: joi_1.default.equal("EVM"),
        then: evmConditions,
        otherwise: joi_1.default.when("chainType", {
            is: joi_1.default.equal("SOLANA"),
            then: solanaConditions,
            otherwise: coreumConditions,
        }),
    }),
    address: joi_1.default.string().required(),
    keyShards: joi_1.default.array().min(5).max(5).required().items(joi_1.default.object()),
    cid: joi_1.default.string().required(),
    // TO aggregator next iteration: "1 or 2 and (3 xor 4)"
    aggregator: joi_1.default.when("conditions.length", {
        is: joi_1.default.number().greater(1),
        then: joi_1.default.string()
            .pattern(/( and | or )/i)
            .required(),
    }),
});
exports.accessConditionSchema = accessConditionSchema;
