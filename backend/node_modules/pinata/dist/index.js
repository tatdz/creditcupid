'use strict';

var chunkBK3CLF3Z_js = require('./chunk-BK3CLF3Z.js');

// src/core/functions/analytics/analyticsDateInterval.ts
var analyticsDateInterval = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const params = new URLSearchParams();
  if (options) {
    const {
      cid,
      gateway_domain,
      start_date,
      end_date,
      file_name,
      user_agent,
      country,
      region,
      referer,
      limit,
      sort_order,
      date_interval,
      sort_by
    } = options;
    if (cid) params.append("cid", cid);
    if (gateway_domain) params.append("gateway_domain", gateway_domain);
    if (start_date) params.append("start_date", start_date);
    if (end_date) params.append("end_date", end_date);
    if (file_name) params.append("file_name", file_name);
    if (user_agent) params.append("user_agent", user_agent.toString());
    if (country) params.append("country", country.toString());
    if (region) params.append("region", region);
    if (referer) params.append("referer", referer.toString());
    if (limit) params.append("limit", limit.toString());
    if (sort_order) params.append("sort_order", sort_order);
    if (sort_by) params.append("sort_by", sort_by);
    if (date_interval) params.append("by", date_interval);
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  const url = `${endpoint}/ipfs/gateway_analytics_time_series?${params.toString()}`;
  try {
    let headers;
    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
      headers = { ...config.customHeaders };
    } else {
      headers = {
        Authorization: `Bearer ${config.pinataJwt}`,
        Source: "sdk/analyticsDateInterval"
      };
    }
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing anaytics usage: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while fetching gateway usage"
    );
  }
};

// src/core/functions/analytics/analyticsTopUsage.ts
var analyticsTopUsage = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const params = new URLSearchParams();
  if (options) {
    const {
      cid,
      gateway_domain,
      start_date,
      end_date,
      file_name,
      user_agent,
      country,
      region,
      referer,
      limit,
      sort_order,
      sort_by,
      attribute
    } = options;
    const domain = gateway_domain || config.pinataGateway;
    if (domain) {
      const cleanDomain = domain.replace(/^https?:\/\//, "");
      params.append("gateway_domain", cleanDomain);
    }
    if (cid) {
      params.append("cid", cid);
    }
    if (start_date) params.append("start_date", start_date);
    if (end_date) params.append("end_date", end_date);
    if (file_name) params.append("file_name", file_name);
    if (user_agent) params.append("user_agent", user_agent.toString());
    if (country) params.append("country", country.toString());
    if (region) params.append("region", region);
    if (referer) params.append("referer", referer.toString());
    if (limit) params.append("limit", limit.toString());
    if (sort_order) params.append("sort_order", sort_order);
    if (sort_by) params.append("sort_by", sort_by);
    if (attribute) params.append("by", attribute);
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  const url = `${endpoint}/ipfs/gateway_analytics_top?${params.toString()}`;
  try {
    let headers;
    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
      headers = { ...config.customHeaders };
    } else {
      headers = {
        Authorization: `Bearer ${config.pinataJwt}`,
        Source: "sdk/analyticsTopUsage"
      };
    }
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing anaytics usage: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while fetching gateway usage"
    );
  }
};

// src/core/functions/authentication/testAuthentication.ts
var testAuthentication = async (config) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  let endpoint = "https://api.pinata.cloud";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/testAuthentication"
    };
  }
  try {
    const request = await fetch(`${endpoint}/data/testAuthentication`, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing authentication: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while testing authentication"
    );
  }
};

// src/core/functions/files/delete.ts
var wait = (milliseconds) => {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
};
var deleteFile = async (config, files, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const responses = [];
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/deleteFile"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  for (const id of files) {
    try {
      const response = await fetch(`${endpoint}/files/${privacy}/${id}`, {
        method: "DELETE",
        headers
      });
      await wait(300);
      if (!response.ok) {
        const errorData = await response.text();
        if (response.status === 401) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            response.status,
            {
              error: errorData,
              code: "HTTP_ERROR",
              metadata: {
                requestUrl: response.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error`, response.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: response.url
          }
        });
      }
      responses.push({
        id,
        status: response.statusText
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error deleting file ${id}: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while deleting file ${id}`;
      }
      responses.push({
        id,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/functions/files/deleteFileVectors.ts
var deleteFileVectors = async (config, fileId) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/vectorizeFile"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  try {
    const request = await fetch(`${endpoint}/vectorize/files/${fileId}`, {
      method: "DELETE",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing vectorize file: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while vectorizing file");
  }
};

// src/core/functions/files/deleteSwap.ts
var deleteSwap = async (config, cid, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/deleteSwap"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/files/${network}/swap/${cid}`, {
      method: "DELETE",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(`Authentication failed`, request.status, {
          error: errorData,
          code: "AUTH_ERROR"
        });
      }
      if (request.status === 403) {
        throw new chunkBK3CLF3Z_js.PinataError(
          "Unauthorized CID Swap Deletion",
          request.status,
          {
            error: errorData,
            code: "UNAUTHORIZED"
          }
        );
      }
      if (request.status === 404) {
        throw new chunkBK3CLF3Z_js.PinataError("CID not pinned to account", request.status, {
          error: errorData,
          code: "NOT_FOUND"
        });
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error occurred`, request.status, {
        error: errorData,
        code: "NETWORK_ERROR"
      });
    }
    return request.statusText;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing deleteSwap: ${error.message}`,
        void 0,
        {
          code: "DELETE_SWAP_ERROR"
        }
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while deleting swap",
      void 0,
      {
        code: "UNKNOWN_ERROR"
      }
    );
  }
};

// src/core/functions/files/list.ts
var listFiles = async (config, privacy, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const params = new URLSearchParams();
  if (options) {
    const {
      name,
      group,
      cid,
      order,
      limit,
      mimeType,
      pageToken,
      cidPending,
      metadata,
      noGroup
    } = options;
    if (limit) params.append("limit", limit.toString());
    if (name) params.append("name", name);
    if (group) params.append("group", group);
    if (cid) params.append("cid", cid);
    if (mimeType) params.append("mimeType", mimeType);
    if (order) params.append("order", order);
    if (pageToken) params.append("pageToken", pageToken);
    if (cidPending) params.append("cidPending", "true");
    if (noGroup) params.append("group", "null");
    if (metadata && typeof metadata === "object") {
      Object.entries(metadata).forEach(([key, value]) => {
        params.append(`keyvalues[${key.toString()}]`, value.toString());
      });
    }
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  const url = `${endpoint}/files/${privacy}?${params.toString()}`;
  try {
    let headers;
    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
      headers = {
        Authorization: `Bearer ${config.pinataJwt}`,
        ...config.customHeaders
      };
    } else {
      headers = {
        Authorization: `Bearer ${config.pinataJwt}`,
        Source: "sdk/listFiles"
      };
    }
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing list files: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while listing files");
  }
};

// src/core/functions/files/pinnedFileUsage.ts
var pinnedFileCount = async (config) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let endpoint = "https://api.pinata.cloud";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/pinnedFileUsage"
    };
  }
  try {
    const request = await fetch(`${endpoint}/data/userPinnedDataTotal`, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.pin_count;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing pinnedFileUsage: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while getting pinned file usage"
    );
  }
};

// src/core/functions/files/swapCid.ts
var swapCid = async (config, options, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const data = JSON.stringify({
    swap_cid: options.swapCid
  });
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/swapCid"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/files/${network}/swap/${options.cid}`,
      {
        method: "PUT",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      if (request.status === 403) {
        throw new chunkBK3CLF3Z_js.PinataError("Unauthorized CID Swap", request.status, {
          error: errorData,
          code: "AUTH_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      if (request.status === 404) {
        throw new chunkBK3CLF3Z_js.PinataError("CID not pinned to account", request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing CID Swap: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while swapping CID");
  }
};

// src/core/functions/files/swapHistory.ts
var swapHistory = async (config, options, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/swapHistory"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/files/${network}/swap/${options.cid}?domain=${options.domain}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      if (request.status === 404) {
        throw new chunkBK3CLF3Z_js.PinataError("CID does not have history", request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error fetching swap history: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while fetching swap history"
    );
  }
};

// src/core/functions/files/totalStorageUsage.ts
var totalStorageUsage = async (config) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let endpoint = "https://api.pinata.cloud";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = { ...config.customHeaders };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/totalStorageUsage"
    };
  }
  try {
    const request = await fetch(`${endpoint}/data/userPinnedDataTotal`, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.pin_size_total;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing totalStorageUsage: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while getting total storage usage"
    );
  }
};

// src/core/functions/files/updateFile.ts
var updateFile = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  if (!options.name && (!options.keyvalues || Object.keys(options.keyvalues).length === 0)) {
    throw new chunkBK3CLF3Z_js.ValidationError(
      "At least one of 'name' or 'keyvalues' must be provided"
    );
  }
  const data = {};
  if (options.name !== void 0) {
    data.name = options.name;
  }
  if (options.keyvalues && Object.keys(options.keyvalues).length > 0) {
    data.keyvalues = options.keyvalues;
  }
  const body = JSON.stringify(data);
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/updateMetadata"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/files/${privacy}/${options.id}`, {
      method: "PUT",
      headers,
      body
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing updateFile: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while updating file");
  }
};

// src/core/functions/files/vectorizeFile.ts
var vectorizeFile = async (config, fileId) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/vectorizeFile"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  try {
    const request = await fetch(`${endpoint}/vectorize/files/${fileId}`, {
      method: "POST",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing vectorize file: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while vectorizing file");
  }
};

// src/core/functions/files/vectorizeQuery.ts
var vectorizeQuery = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/vectorQuery"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  const body = JSON.stringify({
    text: options.query
  });
  try {
    const request = await fetch(
      `${endpoint}/vectorize/groups/${options.groupId}/query`,
      {
        method: "POST",
        headers,
        body
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    if (options.returnFile) {
      if (resData.matches.length === 0) {
        throw new chunkBK3CLF3Z_js.PinataError(`No files returned in query to fetch`);
      }
      const cid = resData.matches[0].cid;
      const fileRes = await getCid(config, cid, "files");
      return fileRes;
    }
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing vectorize file: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while vectorizing file");
  }
};

// src/core/functions/files/queue.ts
var queue = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const params = new URLSearchParams({
    includesCount: "false"
  });
  if (options) {
    const { cid, status, sort, limit, pageToken } = options;
    if (cid) params.append("cid", cid.toString());
    if (status) params.append("status", status.toString());
    if (sort) params.append("sort", sort.toString());
    if (limit) params.append("limit", limit.toString());
    if (pageToken) params.append("pageToken", pageToken.toString());
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  const url = `${endpoint}/files/public/pin_by_cid?${params.toString()}`;
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/pinJobs"
    };
  }
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing pinJobs: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while listing pin jobs");
  }
};

// src/core/functions/files/deletePinRequest.ts
var deletePinRequest = async (config, id) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/deletePinRequest"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const response = await fetch(`${endpoint}/files/public/pin_by_cid/${id}`, {
      method: "DELETE",
      headers
    });
    if (!response.ok) {
      const errorData = await response.text();
      if (response.status === 401) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          response.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: response.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error`, response.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: response.url
        }
      });
    }
    return "OK";
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error deleting pin by request: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while deleting pin by CID request"
    );
  }
};

// src/core/functions/gateway/getCid.ts
var getCid = async (config, cid, gatewayType, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let data;
  let newUrl = `${config?.pinataGateway}/${gatewayType}/${cid}`;
  const params = new URLSearchParams();
  if (options) {
    if (options.width) params.append("img-width", options.width.toString());
    if (options.height) params.append("img-height", options.height.toString());
    if (options.dpr) params.append("img-dpr", options.dpr.toString());
    if (options.fit) params.append("img-fit", options.fit);
    if (options.gravity) params.append("img-gravity", options.gravity);
    if (options.quality)
      params.append("img-quality", options.quality.toString());
    if (options.format) params.append("img-format", options.format);
    if (options.animation !== void 0)
      params.append("img-anim", options.animation.toString());
    if (options.sharpen)
      params.append("img-sharpen", options.sharpen.toString());
    if (options.onError === true) params.append("img-onerror", "redirect");
    if (options.metadata) params.append("img-metadata", options.metadata);
  }
  if (config?.pinataGatewayKey) {
    params.append("pinataGatewayToken", config.pinataGatewayKey);
  }
  const queryString = params.toString();
  if (queryString) {
    newUrl += `?${queryString}`;
  }
  if (gatewayType === "ipfs") {
    const request = await fetch(newUrl);
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication Failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const contentType = request.headers.get("content-type")?.split(";")[0] || null;
    if (contentType?.includes("application/json")) {
      data = await request.json();
    } else if (contentType?.includes("text/")) {
      data = await request.text();
    } else {
      data = await request.blob();
    }
    const res = {
      data,
      contentType
    };
    return res;
  }
  const date = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const payload = JSON.stringify({
    url: newUrl,
    date,
    expires: 30,
    method: "GET"
  });
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/getCid"
    };
  }
  const signedUrlRequest = await fetch(`${endpoint}/files/sign`, {
    method: "POST",
    headers,
    body: payload
  });
  const signedUrl = await signedUrlRequest.json();
  try {
    const request = await fetch(signedUrl.data);
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication Failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const contentType = request.headers.get("content-type")?.split(";")[0] || null;
    if (contentType?.includes("application/json")) {
      data = await request.json();
    } else if (contentType?.includes("text/")) {
      data = await request.text();
    } else {
      data = await request.blob();
    }
    const res = {
      data,
      contentType
    };
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing getCid: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while getting CID contents"
    );
  }
};

// src/core/functions/gateway/convertIPFSUrl.ts
var convertIPFSUrl = async (config, url, gatewayPrefix) => {
  let newUrl;
  let prefix = gatewayPrefix || config?.pinataGateway || "https://gateway.pinata.cloud";
  newUrl = await chunkBK3CLF3Z_js.convertToDesiredGateway(url, prefix);
  if (config?.pinataGatewayKey) {
    `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;
  }
  return newUrl;
};

// src/core/functions/gateway/createAccessLink.ts
var createAccessLink = async (config, options, imgOpts) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let baseUrl;
  if (options?.gateway) {
    baseUrl = options.gateway.startsWith("https://") ? options.gateway : `https://${options.gateway}`;
  } else {
    baseUrl = config.pinataGateway;
  }
  let newUrl = `${baseUrl}/files/${options.cid}`;
  const params = new URLSearchParams();
  if (imgOpts) {
    if (imgOpts.width) params.append("img-width", imgOpts.width.toString());
    if (imgOpts.height) params.append("img-height", imgOpts.height.toString());
    if (imgOpts.dpr) params.append("img-dpr", imgOpts.dpr.toString());
    if (imgOpts.fit) params.append("img-fit", imgOpts.fit);
    if (imgOpts.gravity) params.append("img-gravity", imgOpts.gravity);
    if (imgOpts.quality)
      params.append("img-quality", imgOpts.quality.toString());
    if (imgOpts.format) params.append("img-format", imgOpts.format);
    if (imgOpts.animation !== void 0)
      params.append("img-anim", imgOpts.animation.toString());
    if (imgOpts.sharpen)
      params.append("img-sharpen", imgOpts.sharpen.toString());
    if (imgOpts.onError === true) params.append("img-onerror", "redirect");
    if (imgOpts.metadata) params.append("img-metadata", imgOpts.metadata);
  }
  const queryString = params.toString();
  if (queryString) {
    newUrl += `?${queryString}`;
  }
  const date = options?.date || Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const payload = JSON.stringify({
    url: newUrl,
    date,
    expires: options.expires,
    method: "GET"
  });
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/createSignURL"
    };
  }
  try {
    const request = await fetch(`${endpoint}/files/private/download_link`, {
      method: "POST",
      headers,
      body: payload
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication Failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.data;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error processing createSignedURL: ${error.message}`
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while getting signed url");
  }
};

// src/core/functions/groups/addToGroup.ts
var addToGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const wait3 = (milliseconds) => {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  };
  const responses = [];
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/addToGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  for (const id of options.files) {
    try {
      const response = await fetch(
        `${endpoint}/groups/${privacy}/${options.groupId}/ids/${id}`,
        {
          method: "PUT",
          headers
        }
      );
      await wait3(300);
      if (!response.ok) {
        const errorData = await response.text();
        if (response.status === 401) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            response.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: response.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, response.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: response.url
          }
        });
      }
      responses.push({
        id,
        status: response.statusText
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error adding file ${id} to group: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while adding file ${id} to group`;
      }
      responses.push({
        id,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/functions/groups/createGroup.ts
var createGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const data = JSON.stringify({
    name: options.name,
    is_public: options.isPublic
  });
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/createGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/groups/${privacy}`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing createGroup: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while creating a group");
  }
};

// src/core/functions/groups/deleteGroup.ts
var deleteGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/deleteGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/groups/${privacy}/${options.groupId}`,
      {
        method: "DELETE",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = request.statusText;
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing deleteGroup: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while deleting a group");
  }
};

// src/core/functions/groups/getGroup.ts
var getGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/getGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/groups/${privacy}/${options.groupId}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing getGroup: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while getting info for a group"
    );
  }
};

// src/core/functions/groups/listGroups.ts
var listGroups = async (config, privacy, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/listGroups"
    };
  }
  const params = new URLSearchParams();
  if (options) {
    const { pageToken, name, limit, isPublic } = options;
    if (pageToken) params.append("pageToken", pageToken.toString());
    if (isPublic) params.append("isPublic", isPublic.toString());
    if (name) params.append("name", name);
    if (limit !== void 0) params.append("limit", limit.toString());
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/groups/${privacy}?${params.toString()}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing listGroups: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while listing groups");
  }
};

// src/core/functions/groups/removeFromGroup.ts
var removeFromGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const wait3 = (milliseconds) => {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  };
  const responses = [];
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/addToGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  for (const id of options.files) {
    try {
      const response = await fetch(
        `${endpoint}/groups/${privacy}/${options.groupId}/ids/${id}`,
        {
          method: "DELETE",
          headers
        }
      );
      await wait3(300);
      if (!response.ok) {
        const errorData = await response.text();
        if (response.status === 401) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            response.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: response.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, response.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: response.url
          }
        });
      }
      responses.push({
        id,
        status: response.statusText
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error adding file ${id} to group: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while adding file ${id} to group`;
      }
      responses.push({
        id,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/functions/groups/updateGroup.ts
var updateGroup = async (config, options, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const data = JSON.stringify({
    name: options.name,
    is_public: options.isPublic
  });
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/updateGroup"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/groups/${privacy}/${options.groupId}`,
      {
        method: "PUT",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing updateGroup: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while updating group");
  }
};

// src/core/functions/keys/createKey.ts
var createKey = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/createKey"
    };
  }
  const data = JSON.stringify(options);
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/pinata/keys`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing createKey: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while creating API key");
  }
};

// src/core/functions/keys/listKeys.ts
var listKeys = async (config, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/listKeys"
    };
  }
  const params = new URLSearchParams();
  if (options) {
    const { offset, name, revoked, limitedUse, exhausted } = options;
    if (offset) params.append("offset", offset.toString());
    if (revoked !== void 0) params.append("revoked", revoked.toString());
    if (limitedUse !== void 0)
      params.append("limitedUse", limitedUse.toString());
    if (exhausted !== void 0)
      params.append("exhausted", exhausted.toString());
    if (name) params.append("name", name);
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/pinata/keys?${params.toString()}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.keys;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing listKeys: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while listing API keys");
  }
};

// src/core/functions/keys/revokeKeys.ts
var wait2 = (milliseconds) => {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
};
var revokeKeys = async (config, keys) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
    headers = { ...config.customHeaders };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/revokeKeys"
    };
  }
  const responses = [];
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  for (const key of keys) {
    try {
      const request = await fetch(`${endpoint}/pinata/keys/${key}`, {
        method: "PUT",
        headers
      });
      await wait2(300);
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const result = await request.json();
      responses.push({
        key,
        status: result
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error revoking key ${key}: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while revoking key ${key}`;
      }
      responses.push({
        key,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/functions/uploads/base64.ts
var uploadBase64 = async (config, base64String, network, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const name = options?.metadata?.name ? options?.metadata?.name : "base64 string";
  const buffer = Buffer.from(base64String, "base64");
  const blob = new Blob([buffer]);
  const data = new FormData();
  data.append("file", blob, name);
  data.append("network", network);
  data.append("name", name);
  if (options?.groupId) {
    data.append("group_id", options.groupId);
  }
  if (options?.metadata?.keyvalues) {
    data.append("keyvalues", JSON.stringify(options.metadata.keyvalues));
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      Source: "sdk/base64"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  if (options?.url) {
    try {
      const request = await fetch(options.url, {
        method: "POST",
        body: data
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const res = await request.json();
      const resData = res.data;
      return resData;
    } catch (error) {
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new chunkBK3CLF3Z_js.PinataError(`Error processing base64: ${error.message}`);
      }
      throw new chunkBK3CLF3Z_js.PinataError(
        "An unknown error occurred while trying to upload base64"
      );
    }
  }
  try {
    const request = await fetch(`${endpoint}/files`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    if (options?.vectorize) {
      const vectorReq = await fetch(
        `${endpoint}/vectorize/files/${resData.id}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${jwt}`
          }
        }
      );
      if (vectorReq.ok) {
        resData.vectorized = true;
        return resData;
      } else {
        const errorData = await vectorReq.text();
        throw new chunkBK3CLF3Z_js.NetworkError(
          `HTTP error during vectorization: ${errorData}`,
          vectorReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
    }
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing base64: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while trying to upload base64"
    );
  }
};

// src/core/functions/uploads/createSignedUploadURL.ts
var createSignedUploadURL = async (config, options, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const date = options?.date || Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
  const payload = {
    date,
    expires: options.expires
  };
  if (options.groupId) {
    payload.group_id = options.groupId;
  }
  if (options.name) {
    payload.filename = options.name;
  }
  if (options.keyvalues) {
    payload.keyvalues = options.keyvalues;
  }
  if (network) {
    payload.network = network;
  }
  if (options.streamable) {
    payload.streamable = options.streamable;
  }
  if (options.maxFileSize) {
    payload.max_file_size = options.maxFileSize;
  }
  if (options.mimeTypes) {
    payload.allow_mime_types = options.mimeTypes;
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${config.pinataJwt}`,
      Source: "sdk/createSignURL"
    };
  }
  const maxRetries = 3;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const request = await fetch(`${endpoint}/files/sign`, {
        method: "POST",
        headers,
        cache: "no-store",
        body: JSON.stringify(payload)
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication Failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const res = await request.json();
      return res.data;
    } catch (error) {
      if (error instanceof chunkBK3CLF3Z_js.AuthenticationError) {
        throw error;
      }
      if (error instanceof chunkBK3CLF3Z_js.NetworkError && error.statusCode && error.statusCode >= 400 && error.statusCode < 500 && error.statusCode !== 429) {
        throw error;
      }
      if (attempt === maxRetries) {
        if (error instanceof chunkBK3CLF3Z_js.PinataError) {
          throw error;
        }
        if (error instanceof Error) {
          throw new chunkBK3CLF3Z_js.PinataError(
            `Error processing createSignedURL: ${error.message}`
          );
        }
        throw new chunkBK3CLF3Z_js.PinataError(
          "An unknown error occurred while getting signed url"
        );
      }
      const delay = Math.min(1e3 * Math.pow(2, attempt), 4e3);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while getting signed url");
};

// src/core/functions/uploads/file.ts
var uploadFile = async (config, file, network, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config.pinataJwt;
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  if (file.size > 94371840) {
    let headers2;
    if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
      headers2 = {
        Authorization: `Bearer ${jwt}`,
        ...config.customHeaders
      };
    } else {
      headers2 = {
        Authorization: `Bearer ${jwt}`,
        Source: "sdk/file"
      };
    }
    const name = options?.metadata?.name || file.name || "File from SDK";
    let metadata = `filename ${btoa(name)},filetype ${btoa(file.type)},network ${btoa(network)}`;
    if (options?.groupId) {
      metadata += `,group_id ${btoa(options.groupId)}`;
    }
    if (options?.metadata?.keyvalues) {
      metadata += `,keyvalues ${btoa(JSON.stringify(options.metadata.keyvalues))}`;
    }
    if (options?.streamable) {
      metadata += `,streamable ${btoa("true")}`;
    }
    if (options?.car) {
      metadata += `,car ${btoa("true")}`;
    }
    let updatedEndpoint = `${endpoint}/files`;
    if (options?.url) {
      updatedEndpoint = options.url;
    }
    const urlReq = await fetch(updatedEndpoint, {
      method: "POST",
      headers: {
        "Upload-Length": `${file.size}`,
        "Upload-Metadata": metadata,
        ...headers2
      }
    });
    const url = urlReq.headers.get("Location");
    if (!url) {
      const errorData = await urlReq.text();
      throw new chunkBK3CLF3Z_js.NetworkError("Upload URL not provided", urlReq.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: urlReq.url,
          requestHeaders: urlReq.headers
        }
      });
    }
    const chunkSize = 50 * 1024 * 1024 + 1;
    const totalChunks = Math.ceil(file.size / chunkSize);
    let offset = 0;
    let uploadReq;
    for (let i = 0; i < totalChunks; i++) {
      const chunk = file.slice(offset, offset + chunkSize);
      let retryCount = 0;
      const maxRetries = 5;
      while (retryCount <= maxRetries) {
        try {
          uploadReq = await fetch(url, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/offset+octet-stream",
              "Upload-Offset": offset.toString(),
              ...headers2
            },
            body: chunk
          });
          if (uploadReq.ok) {
            break;
          } else {
            const errorData = await uploadReq.text();
            throw new Error(`HTTP ${uploadReq.status}: ${errorData}`);
          }
        } catch (error) {
          retryCount++;
          if (retryCount > maxRetries) {
            const errorData = uploadReq ? await uploadReq.text().catch(() => "Unknown error") : error instanceof Error ? error.message : String(error);
            throw new chunkBK3CLF3Z_js.NetworkError(
              `HTTP error during chunk upload after ${maxRetries} retries: ${errorData}`,
              uploadReq?.status || 0,
              {
                error: errorData,
                code: "HTTP_ERROR",
                metadata: {
                  requestUrl: uploadReq?.url || url,
                  retriesAttempted: maxRetries
                }
              }
            );
          }
          const delay = Math.min(1e3 * Math.pow(2, retryCount - 1), 1e4);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      offset += chunk.size;
    }
    if (uploadReq.status === 204) {
      const cid = uploadReq.headers.get("upload-cid");
      if (!config.pinataJwt) {
        const data3 = {
          id: "",
          name: "",
          cid,
          size: file.size,
          created_at: "",
          number_of_files: 1,
          group_id: null,
          mime_type: "",
          keyvalues: {},
          vectorized: false,
          network: ""
        };
        return data3;
      }
      let dataEndpoint;
      if (config.endpointUrl) {
        dataEndpoint = config.endpointUrl;
      } else {
        dataEndpoint = "https://api.pinata.cloud/v3";
      }
      const fileInfoReq = await fetch(
        `${dataEndpoint}/files/${network}?cid=${cid}`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${jwt}`
          }
        }
      );
      const fileInfo = await fileInfoReq.json();
      const data2 = fileInfo.data.files[0];
      if (options?.vectorize) {
        const vectorReq = await fetch(
          `${endpoint}/vectorize/files/${data2.id}`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${jwt}`
            }
          }
        );
        if (vectorReq.ok) {
          data2.vectorized = true;
          return data2;
        } else {
          const errorData = await vectorReq.text();
          throw new chunkBK3CLF3Z_js.NetworkError(
            `HTTP error during vectorization: ${errorData}`,
            vectorReq.status,
            {
              error: errorData,
              code: "HTTP_ERROR",
              metadata: {
                requestUrl: vectorReq.url
              }
            }
          );
        }
      }
      return data2;
    }
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      Source: "sdk/file"
    };
  }
  const data = new FormData();
  data.append("file", file, file.name);
  data.append("network", network);
  data.append("name", options?.metadata?.name || file.name || "File from SDK");
  if (options?.groupId) {
    data.append("group_id", options.groupId);
  }
  if (options?.metadata?.keyvalues) {
    data.append("keyvalues", JSON.stringify(options.metadata.keyvalues));
  }
  if (options?.streamable) {
    data.append("streamable", "true");
  }
  if (options?.car) {
    data.append("car", "true");
  }
  if (options?.url) {
    try {
      const request = await fetch(options.url, {
        method: "POST",
        headers,
        body: data
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const res = await request.json();
      const resData = res.data;
      return resData;
    } catch (error) {
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new chunkBK3CLF3Z_js.PinataError(
          `Error uploading file: ${error.message}`,
          void 0,
          {
            error: error.toString()
          }
        );
      }
      throw new chunkBK3CLF3Z_js.PinataError(
        "An unknown error occurred while trying to upload file"
      );
    }
  }
  try {
    const request = await fetch(`${endpoint}/files`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    if (options?.vectorize) {
      const vectorReq = await fetch(
        `${endpoint}/vectorize/files/${resData.id}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${jwt}`
          }
        }
      );
      if (vectorReq.ok) {
        resData.vectorized = true;
        return resData;
      } else {
        const errorData = await vectorReq.text();
        throw new chunkBK3CLF3Z_js.NetworkError(
          `HTTP error during vectorization: ${errorData}`,
          vectorReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
    }
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(
        `Error uploading file: ${error.message}`,
        void 0,
        {
          error: error.toString()
        }
      );
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while trying to upload file"
    );
  }
};

// src/core/functions/uploads/fileArray.ts
var uploadFileArray = async (config, files, network, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const folder = options?.metadata?.name || "folder_from_sdk";
  const data = new FormData();
  for (const file of Array.from(files)) {
    const path = file.webkitRelativePath || `${folder}/${file.name}`;
    data.append("file", file, path);
  }
  data.append(
    "pinataMetadata",
    JSON.stringify({
      name: folder,
      keyvalues: options?.metadata?.keyvalues
    })
  );
  data.append(
    "pinataOptions",
    JSON.stringify({
      groupId: options?.groupId,
      cidVersion: 1
    })
  );
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      Source: "sdk/fileArray"
    };
  }
  let endpoint = "https://api.pinata.cloud/pinning/pinFileToIPFS";
  if (config.legacyUploadUrl) {
    endpoint = config.legacyUploadUrl;
  }
  try {
    const request = await fetch(`${endpoint}`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = {
      id: res.ID,
      name: res.Name,
      cid: res.IpfsHash,
      size: res.PinSize,
      created_at: res.Timestamp,
      number_of_files: res.NumberOfFiles,
      mime_type: res.MimeType,
      group_id: res.GroupId,
      keyvalues: res.Keyvalues,
      vectorized: false,
      network: "public"
    };
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing fileArray: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while uploading an array of files"
    );
  }
};

// src/core/functions/uploads/json.ts
var uploadJson = async (config, jsonData, network, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const json = JSON.stringify(jsonData);
  const blob = new Blob([json]);
  const file = new File([blob], "data.json", { type: "application/json" });
  const data = new FormData();
  data.append("file", file, file.name);
  data.append("network", network);
  data.append("name", options?.metadata?.name || file.name || "File from SDK");
  if (options?.groupId) {
    data.append("group_id", options.groupId);
  }
  if (options?.metadata?.keyvalues) {
    data.append("keyvalues", JSON.stringify(options.metadata.keyvalues));
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      Source: "sdk/json"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  if (options?.url) {
    try {
      const request = await fetch(options.url, {
        method: "POST",
        body: data
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const res = await request.json();
      const resData = res.data;
      return resData;
    } catch (error) {
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new chunkBK3CLF3Z_js.PinataError(`Error processing base64: ${error.message}`);
      }
      throw new chunkBK3CLF3Z_js.PinataError(
        "An unknown error occurred while trying to upload base64"
      );
    }
  }
  try {
    const request = await fetch(`${endpoint}/files`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    if (options?.vectorize) {
      const vectorReq = await fetch(
        `${endpoint}/vectorize/files/${resData.id}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${jwt}`
          }
        }
      );
      if (vectorReq.ok) {
        resData.vectorized = true;
        return resData;
      } else {
        const errorData = await vectorReq.text();
        throw new chunkBK3CLF3Z_js.NetworkError(
          `HTTP error during vectorization: ${errorData}`,
          vectorReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
    }
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing json: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while uploading json");
  }
};

// src/core/functions/uploads/url.ts
var uploadUrl = async (config, url, network, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const data = new FormData();
  const stream = await fetch(url);
  if (!stream.ok) {
    const errorData = await stream.text();
    throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, stream.status, {
      error: errorData,
      code: "HTTP_ERROR",
      metadata: {
        requestUrl: stream.url
      }
    });
  }
  const arrayBuffer = await stream.arrayBuffer();
  const blob = new Blob([arrayBuffer]);
  const name = options?.metadata?.name ?? "url_upload";
  const file = new File([blob], name);
  data.append("file", file, name);
  data.append("network", network);
  data.append("name", name);
  if (options?.groupId) {
    data.append("group_id", options.groupId);
  }
  if (options?.metadata?.keyvalues) {
    data.append("keyvalues", JSON.stringify(options.metadata.keyvalues));
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      Source: "sdk/url"
    };
  }
  let endpoint = "https://uploads.pinata.cloud/v3";
  if (config.uploadUrl) {
    endpoint = config.uploadUrl;
  }
  if (options?.url) {
    try {
      const request = await fetch(options.url, {
        method: "POST",
        body: data
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new chunkBK3CLF3Z_js.AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: {
                requestUrl: request.url
              }
            }
          );
        }
        throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: {
            requestUrl: request.url
          }
        });
      }
      const res = await request.json();
      const resData = res.data;
      return resData;
    } catch (error) {
      if (error instanceof chunkBK3CLF3Z_js.PinataError) {
        throw error;
      }
      if (error instanceof Error) {
        throw new chunkBK3CLF3Z_js.PinataError(`Error processing base64: ${error.message}`);
      }
      throw new chunkBK3CLF3Z_js.PinataError(
        "An unknown error occurred while trying to upload base64"
      );
    }
  }
  try {
    const request = await fetch(`${endpoint}/files`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    if (options?.vectorize) {
      const vectorReq = await fetch(
        `${endpoint}/vectorize/files/${resData.id}`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${jwt}`
          }
        }
      );
      if (vectorReq.ok) {
        resData.vectorized = true;
        return resData;
      } else {
        const errorData = await vectorReq.text();
        throw new chunkBK3CLF3Z_js.NetworkError(
          `HTTP error during vectorization: ${errorData}`,
          vectorReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
    }
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing url: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while uploading by url");
  }
};

// src/core/functions/uploads/cid.ts
var uploadCid = async (config, cid, options) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${jwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${jwt}`,
      "Content-Type": "application/json",
      Source: "sdk/cid"
    };
  }
  const requestBody = {
    cid,
    name: options?.metadata ? options?.metadata?.name : cid,
    keyvalues: options?.metadata?.keyvalues,
    group_id: options?.groupId,
    host_nodes: options?.peerAddresses
  };
  const data = JSON.stringify(requestBody);
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/files/public/pin_by_cid`, {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing cid: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError("An unknown error occurred while pinning by CID");
  }
};

// src/core/classes/analytics/Analytics.ts
var Analytics = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.requests = new AnalyticsRequests(this.config);
    this.bandwidth = new AnalyticsBandwidth(this.config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
    this.requests.updateConfig(newConfig);
    this.bandwidth.updateConfig(newConfig);
  }
  summary(options) {
    return new TimeIntervalAnalyticsBuilder(
      this.config,
      options.domain,
      options.start,
      options.end,
      options.interval
    );
  }
};

// src/core/classes/analytics/utils.ts
var calculateDates = (days) => {
  const end = /* @__PURE__ */ new Date();
  const start = /* @__PURE__ */ new Date();
  start.setDate(start.getDate() - days);
  return {
    start: start.toISOString().split("T")[0],
    end: end.toISOString().split("T")[0]
  };
};

// src/core/classes/analytics/AnalyticsFilter.ts
var AnalyticsFilter = class {
  constructor(config, domain, start, end) {
    this.config = config;
    this.query = {
      gateway_domain: domain,
      start_date: start,
      end_date: end,
      sort_by: "requests",
      // Will be overridden in child classes
      attribute: "cid"
    };
  }
  cid(cid) {
    this.query.attribute = "cid";
    if (cid) {
      this.query.cid = cid;
    }
    return this;
  }
  fileName(fileName) {
    this.query.attribute = "file_name";
    if (fileName) {
      this.query.file_name = fileName;
    }
    return this;
  }
  userAgent(userAgent) {
    this.query.attribute = "user_agent";
    if (userAgent) {
      this.query.user_agent = userAgent;
    }
    return this;
  }
  country(country) {
    this.query.attribute = "country";
    if (country) {
      this.query.country = country;
    }
    return this;
  }
  region(region) {
    this.query.attribute = "region";
    if (region) {
      this.query.region = region;
    }
    return this;
  }
  referer(referer) {
    this.query.attribute = "referer";
    if (referer) {
      this.query.referer = referer;
    }
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  sort(order) {
    this.query.sort_order = order;
    return this;
  }
  days(numberOfDays) {
    const { start, end } = calculateDates(numberOfDays);
    this.query.start_date = start;
    this.query.end_date = end;
    return this;
  }
  then(onfulfilled, onrejected) {
    return analyticsTopUsage(this.config, this.query).then(
      onfulfilled,
      onrejected
    );
  }
};

// src/core/classes/analytics/AnalyticsBandwidth.ts
var AnalyticsBandwidth = class extends AnalyticsFilter {
  constructor(config) {
    super(config, "", "", "");
    this.query.sort_by = "bandwidth";
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  customDates(start, end) {
    if (start) this.query.start_date = start;
    if (end) this.query.end_date = end;
    return this;
  }
  from(domain) {
    this.query.gateway_domain = domain;
    return this;
  }
};

// src/core/classes/analytics/AnalyticsBuilder.ts
var AnalyticsBuilder = class {
  constructor(config, query) {
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
    this.query = query;
  }
  cid(cid) {
    this.query.cid = cid;
    return this;
  }
  fileName(fileName) {
    this.query.file_name = fileName;
    return this;
  }
  userAgent(userAgent) {
    this.query.user_agent = userAgent;
    return this;
  }
  country(country) {
    this.query.country = country;
    return this;
  }
  region(region) {
    this.query.region = region;
    return this;
  }
  referer(referer) {
    this.query.referer = referer;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  sort(order) {
    this.query.sort_order = order;
    return this;
  }
  // private async rateLimit(): Promise<void> {
  // 	this.requestCount++;
  // 	const now = Date.now();
  // 	if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
  // 		const timePassedSinceLastRequest = now - this.lastRequestTime;
  // 		if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
  // 			const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
  // 			await new Promise((resolve) => setTimeout(resolve, delayTime));
  // 		}
  // 		this.requestCount = 0;
  // 	}
  // 	this.lastRequestTime = Date.now();
  // }
  async getAnalytics() {
    throw new Error("getAnalytics method must be implemented in derived class");
  }
  then(onfulfilled, onrejected) {
    return this.getAnalytics().then(onfulfilled, onrejected);
  }
};

// src/core/classes/analytics/AnalyticsRequests.ts
var AnalyticsRequests = class extends AnalyticsFilter {
  constructor(config) {
    super(config, "", "", "");
    this.query.sort_by = "requests";
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  customDates(start, end) {
    if (start) this.query.start_date = start;
    if (end) this.query.end_date = end;
    return this;
  }
  from(domain) {
    this.query.gateway_domain = domain;
    return this;
  }
};

// src/core/classes/analytics/TimeIntervalAnalyticsBuilder.ts
var TimeIntervalAnalyticsBuilder = class extends AnalyticsBuilder {
  constructor(config, domain, start, end, dateInterval) {
    super(config, {
      gateway_domain: domain,
      start_date: start,
      end_date: end,
      date_interval: dateInterval
    });
  }
  sortBy(sortBy) {
    this.query.sort_by = sortBy;
    return this;
  }
  async getAnalytics() {
    return analyticsDateInterval(this.config, this.query);
  }
  async all() {
    return this.getAnalytics();
  }
};

// src/core/classes/groups/GroupsFilter.ts
var FilterGroups = class {
  constructor(config, privacy) {
    this.query = {};
    this.config = config;
    this.privacy = privacy;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  isPublic(isPublic) {
    this.query.isPublic = isPublic;
    return this;
  }
  pageToken(pageToken) {
    this.query.pageToken = pageToken;
    return this;
  }
  then(onfulfilled, onrejected) {
    return this.fetchPage().then((response) => {
      this.nextPageToken = response.next_page_token;
      return response;
    }).then(onfulfilled, onrejected);
  }
  async fetchPage() {
    if (this.nextPageToken) {
      this.query.pageToken = this.nextPageToken;
    }
    return listGroups(this.config, this.privacy, this.query);
  }
  // rate limit, hopefully temporary?
  // private async rateLimit(): Promise<void> {
  // 	this.requestCount++;
  // 	const now = Date.now();
  // 	if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
  // 		const timePassedSinceLastRequest = now - this.lastRequestTime;
  // 		if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
  // 			const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
  // 			await new Promise((resolve) => setTimeout(resolve, delayTime));
  // 		}
  // 		this.requestCount = 0;
  // 	}
  // 	this.lastRequestTime = Date.now();
  // }
  async *[Symbol.asyncIterator]() {
    while (true) {
      const response = await this.fetchPage();
      for (const item of response.groups) {
        yield item;
      }
      if (!response.next_page_token) {
        break;
      }
      this.nextPageToken = response.next_page_token;
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};

// src/core/classes/groups/PublicGroups.ts
var PublicGroups = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  create(options) {
    return createGroup(this.config, options, "public");
  }
  list() {
    return new FilterGroups(this.config, "public");
  }
  get(options) {
    return getGroup(this.config, options, "public");
  }
  addFiles(options) {
    return addToGroup(this.config, options, "public");
  }
  removeFiles(options) {
    return removeFromGroup(this.config, options, "public");
  }
  update(options) {
    return updateGroup(this.config, options, "public");
  }
  delete(options) {
    return deleteGroup(this.config, options, "public");
  }
};

// src/core/classes/groups/PrivateGroups.ts
var PrivateGroups = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  create(options) {
    return createGroup(this.config, options, "private");
  }
  list() {
    return new FilterGroups(this.config, "private");
  }
  get(options) {
    return getGroup(this.config, options, "private");
  }
  addFiles(options) {
    return addToGroup(this.config, options, "private");
  }
  removeFiles(options) {
    return removeFromGroup(this.config, options, "private");
  }
  update(options) {
    return updateGroup(this.config, options, "private");
  }
  delete(options) {
    return deleteGroup(this.config, options, "private");
  }
};

// src/core/classes/groups/Groups.ts
var Groups = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.public = new PublicGroups(config);
    this.private = new PrivateGroups(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
};

// src/core/classes/keys/Keys.ts
var Keys = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  create(options) {
    return createKey(this.config, options);
  }
  list() {
    return new FilterKeys(this.config);
  }
  revoke(keys) {
    return revokeKeys(this.config, keys);
  }
};

// src/core/classes/keys/FilterKeys.ts
var FilterKeys = class {
  // rate limit vars
  // private requestCount = 0;
  // private lastRequestTime = 0;
  // private readonly MAX_REQUESTS_PER_MINUTE = 30;
  // private readonly MINUTE_IN_MS = 60000;
  constructor(config) {
    this.query = {};
    this.config = config;
  }
  offset(offset) {
    this.query.offset = offset;
    return this;
  }
  revoked(revoked) {
    this.query.revoked = revoked;
    return this;
  }
  limitedUse(limitedUse) {
    this.query.limitedUse = limitedUse;
    return this;
  }
  exhausted(exhausted) {
    this.query.exhausted = exhausted;
    return this;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  then(onfulfilled, onrejected) {
    return listKeys(this.config, this.query).then(onfulfilled, onrejected);
  }
  // private async rateLimit(): Promise<void> {
  // 	this.requestCount++;
  // 	const now = Date.now();
  // 	if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
  // 		const timePassedSinceLastRequest = now - this.lastRequestTime;
  // 		if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
  // 			const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
  // 			await new Promise((resolve) => setTimeout(resolve, delayTime));
  // 		}
  // 		this.requestCount = 0;
  // 	}
  // 	this.lastRequestTime = Date.now();
  // }
  async *[Symbol.asyncIterator]() {
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      this.query.offset = offset;
      const items = await listKeys(this.config, this.query);
      for (const item of items) {
        yield item;
      }
      if (items.length === 0) {
        hasMore = false;
      } else {
        offset += items.length;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};

// src/core/classes/gateways/Gateways.ts
var Gateways = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.public = new PublicGateways(config);
    this.private = new PrivateGateways(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
};

// src/core/classes/gateways/OptimizeImageCreateSignedUrl.ts
var OptimizeImageCreateAccessLink = class {
  constructor(config, urlOpts) {
    this.imgOpts = {};
    this.config = config;
    this.urlOpts = urlOpts;
  }
  optimizeImage(options) {
    this.imgOpts = { ...this.imgOpts, ...options };
    return this;
  }
  then(onfulfilled, onrejected) {
    return createAccessLink(this.config, this.urlOpts, this.imgOpts).then(
      onfulfilled,
      onrejected
    );
  }
};

// src/core/classes/gateways/OptimizeImageGetCid.ts
var OptimizeImageGetCid = class {
  constructor(config, cid, gatewayType) {
    this.options = {};
    this.config = config;
    this.cid = cid;
    this.gatewayType = gatewayType;
  }
  optimizeImage(options) {
    this.options = { ...this.options, ...options };
    return this;
  }
  then(onfulfilled, onrejected) {
    return getCid(this.config, this.cid, this.gatewayType, this.options).then(
      onfulfilled,
      onrejected
    );
  }
};

// src/core/classes/gateways/PrivateGateways.ts
var PrivateGateways = class {
  constructor(config) {
    this.config = config;
  }
  get(cid) {
    return new OptimizeImageGetCid(this.config, cid, "files");
  }
  createAccessLink(options) {
    return new OptimizeImageCreateAccessLink(this.config, options);
  }
};

// src/core/classes/gateways/PublicGateways.ts
var PublicGateways = class {
  constructor(config) {
    this.config = config;
  }
  get(cid) {
    return new OptimizeImageGetCid(this.config, cid, "ipfs");
  }
  convert(url, gatewayPrefix) {
    return convertIPFSUrl(this.config, url, gatewayPrefix);
  }
};

// src/core/functions/files/getFile.ts
var getFile = async (config, id, privacy) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      ...config.customHeaders
    };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/getFile"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(`${endpoint}/files/${privacy}/${id}`, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    const resData = res.data;
    return resData;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing getGroup: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while getting info for a group"
    );
  }
};

// src/core/classes/files/FilterFiles.ts
var FilterFiles = class {
  // rate limit vars
  // private requestCount = 0;
  // private lastRequestTime = 0;
  // private readonly MAX_REQUESTS_PER_MINUTE = 30;
  // private readonly MINUTE_IN_MS = 60000;
  constructor(config, privacy) {
    this.query = {};
    this.config = config;
    this.privacy = privacy;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  group(group) {
    this.query.group = group;
    return this;
  }
  cid(cid) {
    this.query.cid = cid;
    return this;
  }
  mimeType(mimeType) {
    this.query.mimeType = mimeType;
    return this;
  }
  order(order) {
    this.query.order = order;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  cidPending(cidPending) {
    this.query.cidPending = cidPending;
    return this;
  }
  keyvalues(keyvalues) {
    this.query.metadata = keyvalues;
    return this;
  }
  noGroup(noGroup) {
    this.query.noGroup = noGroup;
    return this;
  }
  pageToken(pageToken) {
    this.query.pageToken = pageToken;
    return this;
  }
  then(onfulfilled, onrejected) {
    return this.fetchPage().then(onfulfilled, onrejected);
  }
  async fetchPage() {
    if (this.currentPageToken) {
      this.query.pageToken = this.currentPageToken;
    }
    const response = await listFiles(this.config, this.privacy, this.query);
    this.currentPageToken = response.next_page_token;
    return response;
  }
  // // rate limit, hopefully temporary?
  // private async rateLimit(): Promise<void> {
  // 	this.requestCount++;
  // 	const now = Date.now();
  // 	if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
  // 		const timePassedSinceLastRequest = now - this.lastRequestTime;
  // 		if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
  // 			const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
  // 			await new Promise((resolve) => setTimeout(resolve, delayTime));
  // 		}
  // 		this.requestCount = 0;
  // 	}
  // 	this.lastRequestTime = Date.now();
  // }
  async *[Symbol.asyncIterator]() {
    while (true) {
      const items = await this.fetchPage();
      for (const item of items.files) {
        yield item;
      }
      if (!this.currentPageToken) {
        break;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};

// src/core/classes/files/FilterQueue.ts
var FilterQueue = class {
  constructor(config) {
    this.query = {};
    // rate limit vars
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
  }
  cid(cid) {
    this.query.cid = cid;
    return this;
  }
  status(status) {
    this.query.status = status;
    return this;
  }
  pageLimit(limit) {
    this.query.limit = limit;
    return this;
  }
  pageToken(pageToken) {
    this.query.pageToken = pageToken;
    return this;
  }
  async fetchPage() {
    if (this.currentPageToken) {
      this.query.pageToken = this.currentPageToken;
    }
    const response = await queue(this.config, this.query);
    this.currentPageToken = response.next_page_token;
    return response;
  }
  sort(sort) {
    this.query.sort = sort;
    return this;
  }
  then(onfulfilled, onrejected) {
    return queue(this.config, this.query).then(onfulfilled, onrejected);
  }
  // rate limit, hopefully temporary?
  async rateLimit() {
    this.requestCount++;
    const now = Date.now();
    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
      const timePassedSinceLastRequest = now - this.lastRequestTime;
      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
        await new Promise((resolve) => setTimeout(resolve, delayTime));
      }
      this.requestCount = 0;
    }
    this.lastRequestTime = Date.now();
  }
  async *[Symbol.asyncIterator]() {
    while (true) {
      const items = await this.fetchPage();
      for (const item of items.jobs) {
        yield item;
      }
      if (!this.currentPageToken) {
        break;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};

// src/core/classes/files/PublicFiles.ts
var PublicFiles = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  list() {
    return new FilterFiles(this.config, "public");
  }
  get(id) {
    return getFile(this.config, id, "public");
  }
  delete(files) {
    return deleteFile(this.config, files, "public");
  }
  update(options) {
    return updateFile(this.config, options, "public");
  }
  addSwap(options) {
    return swapCid(this.config, options, "public");
  }
  getSwapHistory(options) {
    return swapHistory(this.config, options, "public");
  }
  deleteSwap(cid) {
    return deleteSwap(this.config, cid, "public");
  }
  queue() {
    return new FilterQueue(this.config);
  }
  deletePinRequest(requestId) {
    return deletePinRequest(this.config, requestId);
  }
};

// src/core/classes/files/PrivateFiles.ts
var PrivateFiles = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  list() {
    return new FilterFiles(this.config, "private");
  }
  get(id) {
    return getFile(this.config, id, "private");
  }
  delete(files) {
    return deleteFile(this.config, files, "private");
  }
  update(options) {
    return updateFile(this.config, options, "private");
  }
  addSwap(options) {
    return swapCid(this.config, options, "private");
  }
  getSwapHistory(options) {
    return swapHistory(this.config, options, "private");
  }
  deleteSwap(cid) {
    return deleteSwap(this.config, cid, "private");
  }
  vectorize(fileId) {
    return vectorizeFile(this.config, fileId);
  }
  queryVectors(options) {
    return vectorizeQuery(this.config, options);
  }
  deleteVectors(fileId) {
    return deleteFileVectors(this.config, fileId);
  }
};

// src/core/classes/files/Files.ts
var Files = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.public = new PublicFiles(config);
    this.private = new PrivateFiles(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
};

// src/core/classes/uploads/UploadBuilder.ts
var UploadBuilder = class {
  constructor(config, uploadFunction, ...args) {
    this.metadata = {};
    this.config = config;
    this.uploadFunction = uploadFunction;
    this.args = args;
  }
  // Replace addMetadata with these two methods:
  name(name) {
    if (!this.metadata) {
      this.metadata = {};
    }
    this.metadata.name = name;
    return this;
  }
  keyvalues(keyvalues) {
    if (!this.metadata) {
      this.metadata = {};
    }
    this.metadata.keyvalues = keyvalues;
    return this;
  }
  key(jwt) {
    this.keys = jwt;
    return this;
  }
  vectorize() {
    this.vector = true;
    return this;
  }
  url(url) {
    this.uploadUrl = url;
    return this;
  }
  // cidVersion(v: 0 | 1): UploadBuilder<T> {
  // 	this.version = v;
  // 	return this;
  // }
  group(groupId) {
    this.groupId = groupId;
    return this;
  }
  streamable() {
    this.isStreamable = true;
    return this;
  }
  car() {
    this.carFormat = true;
    return this;
  }
  peerAddress(peerAddresses) {
    this.peerAddresses = peerAddresses;
    return this;
  }
  then(onfulfilled, onrejected) {
    const options = this.args[this.args.length - 1] || {};
    if (this.metadata) {
      options.metadata = this.metadata;
    }
    if (this.keys) {
      options.keys = this.keys;
    }
    if (this.groupId) {
      options.groupId = this.groupId;
    }
    if (this.vector) {
      options.vectorize = this.vector;
    }
    if (this.uploadUrl) {
      options.url = this.uploadUrl;
    }
    if (this.isStreamable) {
      options.streamable = this.isStreamable;
    }
    if (this.peerAddresses) {
      options.peerAddresses = this.peerAddresses;
    }
    if (this.carFormat) {
      options.car = this.carFormat;
    }
    this.args[this.args.length - 1] = options;
    return this.uploadFunction(this.config, ...this.args).then(
      onfulfilled,
      onrejected
    );
  }
};

// src/core/classes/uploads/PublicUpload.ts
var PublicUpload = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  file(file, options) {
    return new UploadBuilder(
      this.config,
      (config, file2, options2) => uploadFile(config, file2, "public", options2),
      file,
      options
    );
  }
  fileArray(files, options) {
    return new UploadBuilder(
      this.config,
      (config, file, options2) => uploadFileArray(config, file, "public", options2),
      files,
      options
    );
  }
  base64(base64String, options) {
    return new UploadBuilder(
      this.config,
      (config, base64String2, options2) => uploadBase64(config, base64String2, "public", options2),
      base64String,
      options
    );
  }
  url(url, options) {
    return new UploadBuilder(
      this.config,
      (config, url2, options2) => uploadUrl(config, url2, "public", options2),
      url,
      options
    );
  }
  json(data, options) {
    return new UploadBuilder(
      this.config,
      (config, data2, options2) => uploadJson(config, data2, "public", options2),
      data,
      options
    );
  }
  cid(cid, options) {
    return new UploadBuilder(
      this.config,
      (config, cid2, options2) => uploadCid(config, cid2, options2),
      cid,
      options
    );
  }
  createSignedURL(options) {
    return createSignedUploadURL(this.config, options, "public");
  }
};

// src/core/classes/uploads/PrivateUpload.ts
var PrivateUpload = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  file(file, options) {
    return new UploadBuilder(
      this.config,
      (config, file2, options2) => uploadFile(config, file2, "private", options2),
      file,
      options
    );
  }
  // Reserved for future release
  // fileArray(
  // 	files: FileObject[],
  // 	options?: UploadOptions,
  // ): UploadBuilder<UploadResponse> {
  // 	return new UploadBuilder(
  // 		this.config,
  // 		(config, file, options) =>
  // 			uploadFileArray(config, file, "private", options),
  // 		files,
  // 		options,
  // 	);
  // }
  base64(base64String, options) {
    return new UploadBuilder(
      this.config,
      (config, base64String2, options2) => uploadBase64(config, base64String2, "private", options2),
      base64String,
      options
    );
  }
  url(url, options) {
    return new UploadBuilder(
      this.config,
      (config, url2, options2) => uploadUrl(config, url2, "private", options2),
      url,
      options
    );
  }
  json(data, options) {
    return new UploadBuilder(
      this.config,
      (config, data2, options2) => uploadJson(config, data2, "private", options2),
      data,
      options
    );
  }
  createSignedURL(options) {
    return createSignedUploadURL(this.config, options, "private");
  }
};

// src/core/classes/uploads/Upload.ts
var Upload = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.public = new PublicUpload(config);
    this.private = new PrivateUpload(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
};

// src/core/functions/signatures/addSignature.ts
var addSignature = async (config, options, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  const data = JSON.stringify({
    signature: options.signature,
    address: options.address
  });
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = { ...config.customHeaders };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/addSignature"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/files/${network}/signature/${options.cid}`,
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      if (request.status === 403) {
        throw new chunkBK3CLF3Z_js.PinataError(
          "Unauthorized signing, you must be the original owner of the file and it must not have a signature",
          request.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.data;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing addSignature: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while adding signature to CID"
    );
  }
};

// src/core/functions/signatures/getSignature.ts
var getSignature = async (config, cid, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = { ...config.customHeaders };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/getSignature"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/files/${network}/signature/${cid}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    const res = await request.json();
    return res.data;
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing getSignature: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while fetching signature for CID"
    );
  }
};

// src/core/functions/signatures/removeSignature.ts
var removeSignature = async (config, cid, network) => {
  if (!config) {
    throw new chunkBK3CLF3Z_js.ValidationError("Pinata configuration is missing");
  }
  let headers;
  if (config.customHeaders && Object.keys(config.customHeaders).length > 0) {
    headers = { ...config.customHeaders };
  } else {
    headers = {
      Authorization: `Bearer ${config.pinataJwt}`,
      "Content-Type": "application/json",
      Source: "sdk/removeSignature"
    };
  }
  let endpoint = "https://api.pinata.cloud/v3";
  if (config.endpointUrl) {
    endpoint = config.endpointUrl;
  }
  try {
    const request = await fetch(
      `${endpoint}/files/${network}/signature/${cid}`,
      {
        method: "DELETE",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.text();
      if (request.status === 401 || request.status === 403) {
        throw new chunkBK3CLF3Z_js.AuthenticationError(
          `Authentication failed: ${errorData}`,
          request.status,
          {
            error: errorData,
            code: "AUTH_ERROR",
            metadata: {
              requestUrl: request.url
            }
          }
        );
      }
      throw new chunkBK3CLF3Z_js.NetworkError(`HTTP error: ${errorData}`, request.status, {
        error: errorData,
        code: "HTTP_ERROR",
        metadata: {
          requestUrl: request.url
        }
      });
    }
    return "OK";
  } catch (error) {
    if (error instanceof chunkBK3CLF3Z_js.PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new chunkBK3CLF3Z_js.PinataError(`Error processing addSignature: ${error.message}`);
    }
    throw new chunkBK3CLF3Z_js.PinataError(
      "An unknown error occurred while adding signature to CID"
    );
  }
};

// src/core/classes/signatures/PublicSignatures.ts
var PublicSignatures = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
  add(options) {
    return addSignature(this.config, options, "public");
  }
  get(cid) {
    return getSignature(this.config, cid, "public");
  }
  delete(cid) {
    return removeSignature(this.config, cid, "public");
  }
};

// src/core/classes/signatures/Signatures.ts
var Signatures = class {
  //private: PrivateSignatures
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.public = new PublicSignatures(config);
  }
  updateConfig(newConfig) {
    this.config = newConfig;
  }
};

// src/core/pinataSDK.ts
var PinataSDK = class {
  constructor(config) {
    this.config = chunkBK3CLF3Z_js.formatConfig(config);
    this.files = new Files(this.config);
    this.upload = new Upload(this.config);
    this.gateways = new Gateways(this.config);
    this.keys = new Keys(this.config);
    this.groups = new Groups(this.config);
    this.analytics = new Analytics(this.config);
    this.signatures = new Signatures(this.config);
  }
  setNewHeaders(headers) {
    if (!this.config) {
      this.config = { pinataJwt: "", customHeaders: {} };
    }
    this.config.customHeaders = { ...this.config.customHeaders, ...headers };
    this.files.updateConfig(this.config);
    this.upload.updateConfig(this.config);
    this.gateways.updateConfig(this.config);
    this.keys.updateConfig(this.config);
    this.groups.updateConfig(this.config);
    this.analytics.updateConfig(this.config);
    this.signatures.updateConfig(this.config);
  }
  setNewJwt(jwt) {
    if (!this.config) {
      this.config = { pinataJwt: "" };
    }
    this.config.pinataJwt = jwt;
    this.files.updateConfig(this.config);
    this.upload.updateConfig(this.config);
    this.gateways.updateConfig(this.config);
    this.keys.updateConfig(this.config);
    this.groups.updateConfig(this.config);
    this.analytics.updateConfig(this.config);
    this.signatures.updateConfig(this.config);
  }
  testAuthentication() {
    return testAuthentication(this.config);
  }
};

Object.defineProperty(exports, "AuthenticationError", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.AuthenticationError; }
});
Object.defineProperty(exports, "NetworkError", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.NetworkError; }
});
Object.defineProperty(exports, "PinataError", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.PinataError; }
});
Object.defineProperty(exports, "ValidationError", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.ValidationError; }
});
Object.defineProperty(exports, "containsCID", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.containsCID; }
});
Object.defineProperty(exports, "convertToDesiredGateway", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.convertToDesiredGateway; }
});
Object.defineProperty(exports, "formatConfig", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.formatConfig; }
});
Object.defineProperty(exports, "getFileIdFromUrl", {
  enumerable: true,
  get: function () { return chunkBK3CLF3Z_js.getFileIdFromUrl; }
});
exports.PinataSDK = PinataSDK;
exports.addToGroup = addToGroup;
exports.analyticsDateInterval = analyticsDateInterval;
exports.analyticsTopUsage = analyticsTopUsage;
exports.convertIPFSUrl = convertIPFSUrl;
exports.createAccessLink = createAccessLink;
exports.createGroup = createGroup;
exports.createKey = createKey;
exports.createSignedUploadURL = createSignedUploadURL;
exports.deleteFile = deleteFile;
exports.deleteFileVectors = deleteFileVectors;
exports.deleteGroup = deleteGroup;
exports.deletePinRequest = deletePinRequest;
exports.deleteSwap = deleteSwap;
exports.getCid = getCid;
exports.getGroup = getGroup;
exports.listFiles = listFiles;
exports.listGroups = listGroups;
exports.listKeys = listKeys;
exports.pinnedFileCount = pinnedFileCount;
exports.queue = queue;
exports.removeFromGroup = removeFromGroup;
exports.revokeKeys = revokeKeys;
exports.swapCid = swapCid;
exports.swapHistory = swapHistory;
exports.testAuthentication = testAuthentication;
exports.totalStorageUsage = totalStorageUsage;
exports.updateFile = updateFile;
exports.updateGroup = updateGroup;
exports.uploadBase64 = uploadBase64;
exports.uploadCid = uploadCid;
exports.uploadFile = uploadFile;
exports.uploadFileArray = uploadFileArray;
exports.uploadJson = uploadJson;
exports.uploadUrl = uploadUrl;
exports.vectorizeFile = vectorizeFile;
exports.vectorizeQuery = vectorizeQuery;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map