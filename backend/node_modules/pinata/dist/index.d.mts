import { D as DeleteResponse, V as VectorizeFileResponse, F as FileListQuery, a as FileListResponse, S as SwapCidOptions, b as SwapCidResponse, c as SwapHistoryOptions, U as UpdateFileOptions, d as FileListItem, e as VectorizeQuery, f as VectorizeQueryResponse, G as GetCIDResponse, P as PinQueueQuery, g as PinQueueResponse, O as OptimizeImageOptions, A as AccessLinkOptions, h as UploadOptions, i as UploadResponse, j as SignedUploadUrlOptions, J as JsonBody, k as UploadCIDOptions, l as PinByCIDResponse, m as PinQueueItem } from './gateway-tools-Cd7xutmh.mjs';
export { s as AuthenticationError, q as ContainsCIDResponse, C as ContentType, n as FileObject, N as NetworkError, r as PinataError, o as PinataMetadata, t as ValidationError, p as VectorQueryMatch, u as containsCID, v as convertToDesiredGateway } from './gateway-tools-Cd7xutmh.mjs';

type PinataConfig = {
    pinataJwt?: string;
    pinataGateway?: string;
    pinataGatewayKey?: string;
    customHeaders?: Record<string, string>;
    endpointUrl?: string;
    uploadUrl?: string;
    legacyUploadUrl?: string;
};

type AnalyticsQuery = {
    gateway_domain: string;
    start_date: string;
    end_date: string;
    cid?: string;
    file_name?: string;
    user_agent?: string;
    country?: string;
    region?: string;
    referer?: string;
    limit?: number;
    sort_order?: "asc" | "desc";
};
type TopAnalyticsQuery = AnalyticsQuery & {
    sort_by: "requests" | "bandwidth";
    attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name";
};
type TopAnalyticsResponse = {
    data: TopAnalyticsItem[];
};
type TopAnalyticsItem = {
    value: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalAnalyticsQuery = AnalyticsQuery & {
    sort_by?: "requests" | "bandwidth";
    date_interval: "day" | "week";
};
type TimePeriodItem = {
    period_start_time: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalAnalyticsResponse = {
    total_requests: number;
    total_bandwidth: number;
    time_periods: TimePeriodItem[];
};
type UserPinnedDataResponse = {
    pin_count: number;
    pin_size_total: number;
    pin_size_with_replications_total: number;
};

type GroupOptions = {
    name: string;
    isPublic?: boolean;
};
type UpdateGroupOptions = {
    groupId: string;
    name?: string;
    isPublic?: boolean;
};
type GetGroupOptions = {
    groupId: string;
};
type GroupListResponse = {
    groups: GroupResponseItem[];
    next_page_token: string;
};
type GroupResponseItem = {
    id: string;
    is_public: boolean;
    name: string;
    createdAt: string;
};
type GroupQueryOptions = {
    name?: string;
    limit?: number;
    pageToken?: string;
    isPublic?: boolean;
};
type GroupCIDOptions = {
    groupId: string;
    files: string[];
};
type UpdateGroupFilesResponse = {
    id: string;
    status: string;
};

type KeyPermissions = {
    admin?: boolean;
    endpoints?: Endpoints;
    resources?: ResourcePermission[];
};
type ResourcePermission = "org:read" | "org:write" | "org:files:read" | "org:files:write" | "org:groups:read" | "org:groups:write" | "org:gateways:read" | "org:gateways:write" | "org:analytics:read" | "org:analytics:write";
type Endpoints = {
    data?: DataEndponts;
    pinning?: PinningEndpoints;
};
type DataEndponts = {
    pinList?: boolean;
    userPinnedDataTotal?: boolean;
};
type PinningEndpoints = {
    hashMetadata?: boolean;
    hashPinPolicy?: boolean;
    pinByHash?: boolean;
    pinFileToIPFS?: boolean;
    pinJSONToIPFS?: boolean;
    pinJobs?: boolean;
    unpin?: boolean;
    userPinPolicy?: boolean;
};
type KeyOptions = {
    keyName: string;
    permissions: KeyPermissions;
    maxUses?: number;
};
type KeyResponse = {
    JWT: string;
    pinata_api_key: string;
    pinata_api_secret: string;
};
type KeyListQuery = {
    revoked?: boolean;
    limitedUse?: boolean;
    exhausted?: boolean;
    name?: string;
    offset?: number;
};
type KeyListItem = {
    id: string;
    name: string;
    key: string;
    secret: string;
    max_uses: number;
    uses: number;
    user_id: string;
    scopes: KeyScopes;
    revoked: boolean;
    createdAt: string;
    updatedAt: string;
};
type KeyScopes = {
    endpoints: {
        pinning: {
            pinFileToIPFS: boolean;
            pinJSONToIPFS: boolean;
        };
    };
    admin: boolean;
};
type KeyListResponse = {
    keys: KeyListItem[];
    count: number;
};
type RevokeKeyResponse = {
    key: string;
    status: string;
};

type SignatureOptions = {
    cid: string;
    signature: string;
    address: string;
};
type SignatureResponse = {
    cid: string;
    signature: string;
};

declare const analyticsDateInterval: (config: PinataConfig | undefined, options?: TimeIntervalAnalyticsQuery) => Promise<TimeIntervalAnalyticsResponse>;

declare const analyticsTopUsage: (config: PinataConfig | undefined, options?: TopAnalyticsQuery) => Promise<TopAnalyticsResponse>;

declare const testAuthentication: (config: PinataConfig | undefined) => Promise<string>;

declare const deleteFile: (config: PinataConfig | undefined, files: string[], privacy: "public" | "private") => Promise<DeleteResponse[]>;

declare const deleteFileVectors: (config: PinataConfig | undefined, fileId: string) => Promise<VectorizeFileResponse>;

declare const deleteSwap: (config: PinataConfig | undefined, cid: string, network: "public" | "private") => Promise<string>;

declare const listFiles: (config: PinataConfig | undefined, privacy: "private" | "public", options?: FileListQuery) => Promise<FileListResponse>;

declare const pinnedFileCount: (config: PinataConfig | undefined) => Promise<number>;

declare const swapCid: (config: PinataConfig | undefined, options: SwapCidOptions, network: "public" | "private") => Promise<SwapCidResponse>;

declare const swapHistory: (config: PinataConfig | undefined, options: SwapHistoryOptions, network: "public" | "private") => Promise<SwapCidResponse[]>;

declare const totalStorageUsage: (config: PinataConfig | undefined) => Promise<number>;

declare const updateFile: (config: PinataConfig | undefined, options: UpdateFileOptions, privacy: "public" | "private") => Promise<FileListItem>;

declare const vectorizeFile: (config: PinataConfig | undefined, fileId: string) => Promise<VectorizeFileResponse>;

declare const vectorizeQuery: (config: PinataConfig | undefined, options: VectorizeQuery) => Promise<VectorizeQueryResponse | GetCIDResponse>;

declare const queue: (config: PinataConfig | undefined, options?: PinQueueQuery) => Promise<PinQueueResponse>;

declare const deletePinRequest: (config: PinataConfig | undefined, id: string) => Promise<string>;

declare const getCid: (config: PinataConfig | undefined, cid: string, gatewayType?: "ipfs" | "files", options?: OptimizeImageOptions) => Promise<GetCIDResponse>;

declare const convertIPFSUrl: (config: PinataConfig | undefined, url: string, gatewayPrefix?: string) => Promise<string>;

declare const createAccessLink: (config: PinataConfig | undefined, options: AccessLinkOptions, imgOpts: OptimizeImageOptions) => Promise<string>;

declare const addToGroup: (config: PinataConfig | undefined, options: GroupCIDOptions, privacy: "public" | "private") => Promise<UpdateGroupFilesResponse[]>;

declare const createGroup: (config: PinataConfig | undefined, options: GroupOptions, privacy: "public" | "private") => Promise<GroupResponseItem>;

declare const deleteGroup: (config: PinataConfig | undefined, options: GetGroupOptions, privacy: "public" | "private") => Promise<string>;

declare const getGroup: (config: PinataConfig | undefined, options: GetGroupOptions, privacy: "public" | "private") => Promise<GroupResponseItem>;

declare const listGroups: (config: PinataConfig | undefined, privacy: "public" | "private", options?: GroupQueryOptions) => Promise<GroupListResponse>;

declare const removeFromGroup: (config: PinataConfig | undefined, options: GroupCIDOptions, privacy: "public" | "private") => Promise<UpdateGroupFilesResponse[]>;

declare const updateGroup: (config: PinataConfig | undefined, options: UpdateGroupOptions, privacy: "public" | "private") => Promise<GroupResponseItem>;

declare const createKey: (config: PinataConfig | undefined, options: KeyOptions) => Promise<KeyResponse>;

declare const listKeys: (config: PinataConfig | undefined, options?: KeyListQuery) => Promise<KeyListItem[]>;

declare const revokeKeys: (config: PinataConfig | undefined, keys: string[]) => Promise<RevokeKeyResponse[]>;

declare const uploadBase64: (config: PinataConfig | undefined, base64String: string, network: "private" | "public", options?: UploadOptions) => Promise<UploadResponse>;

declare const createSignedUploadURL: (config: PinataConfig | undefined, options: SignedUploadUrlOptions, network: "public" | "private") => Promise<string>;

declare const uploadFile: (config: PinataConfig | undefined, file: File, network: "public" | "private", options?: UploadOptions) => Promise<UploadResponse>;

declare const uploadFileArray: (config: PinataConfig | undefined, files: File[], network: "public" | "private", options?: UploadOptions) => Promise<UploadResponse>;

declare const uploadJson: <T extends JsonBody>(config: PinataConfig | undefined, jsonData: T, network: "public" | "private", options?: UploadOptions) => Promise<UploadResponse>;

declare const uploadUrl: (config: PinataConfig | undefined, url: string, network: "public" | "private", options?: UploadOptions) => Promise<UploadResponse>;

declare const uploadCid: (config: PinataConfig | undefined, cid: string, options?: UploadCIDOptions) => Promise<PinByCIDResponse>;

declare class Analytics {
    config: PinataConfig | undefined;
    requests: AnalyticsRequests;
    bandwidth: AnalyticsBandwidth;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    summary(options: {
        domain: string;
        start: string;
        end: string;
        interval: "day" | "week";
    }): TimeIntervalAnalyticsBuilder;
}

declare class AnalyticsFilter {
    protected config: PinataConfig | undefined;
    protected query: TopAnalyticsQuery;
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string);
    cid(cid?: string): this;
    fileName(fileName?: string): this;
    userAgent(userAgent?: string): this;
    country(country?: string): this;
    region(region?: string): this;
    referer(referer?: string): this;
    limit(limit: number): this;
    sort(order: "asc" | "desc"): this;
    days(numberOfDays: number): this;
    then(onfulfilled?: ((value: TopAnalyticsResponse) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
}

declare class AnalyticsBandwidth extends AnalyticsFilter {
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    customDates(start?: string, end?: string): this;
    from(domain: string): this;
}

declare class AnalyticsBuilder<T extends AnalyticsQuery, R> {
    protected config: PinataConfig | undefined;
    protected query: T;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined, query: T);
    cid(cid: string): this;
    fileName(fileName: string): this;
    userAgent(userAgent: string): this;
    country(country: string): this;
    region(region: string): this;
    referer(referer: string): this;
    limit(limit: number): this;
    sort(order: "asc" | "desc"): this;
    protected getAnalytics(): Promise<R>;
    then(onfulfilled?: ((value: R) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
}

declare class AnalyticsRequests extends AnalyticsFilter {
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    customDates(start?: string, end?: string): this;
    from(domain: string): this;
}

declare class TimeIntervalAnalyticsBuilder extends AnalyticsBuilder<TimeIntervalAnalyticsQuery, TimeIntervalAnalyticsResponse> {
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string, dateInterval: "day" | "week");
    sortBy(sortBy: "requests" | "bandwidth"): this;
    protected getAnalytics(): Promise<TimeIntervalAnalyticsResponse>;
    all(): Promise<TimeIntervalAnalyticsResponse>;
}

declare class FilterGroups {
    private config;
    private query;
    private privacy;
    private nextPageToken;
    constructor(config: PinataConfig | undefined, privacy: "private" | "public");
    name(name: string): FilterGroups;
    limit(limit: number): FilterGroups;
    isPublic(isPublic: boolean): FilterGroups;
    pageToken(pageToken: string): FilterGroups;
    then(onfulfilled?: ((value: GroupListResponse) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<GroupListResponse>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<GroupResponseItem, void, unknown>;
    all(): Promise<GroupResponseItem[]>;
}

declare class PublicGroups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    addFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    removeFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}

declare class PrivateGroups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    addFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    removeFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}

declare class Groups {
    config: PinataConfig | undefined;
    public: PublicGroups;
    private: PrivateGroups;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
}

declare class Keys {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: KeyOptions): Promise<KeyResponse>;
    list(): FilterKeys;
    revoke(keys: string[]): Promise<RevokeKeyResponse[]>;
}

declare class FilterKeys {
    private config;
    private query;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterKeys;
    revoked(revoked: boolean): FilterKeys;
    limitedUse(limitedUse: boolean): FilterKeys;
    exhausted(exhausted: boolean): FilterKeys;
    name(name: string): FilterKeys;
    then(onfulfilled?: ((value: KeyListItem[]) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
    [Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown>;
    all(): Promise<KeyListItem[]>;
}

declare class Gateways {
    config: PinataConfig | undefined;
    public: PublicGateways;
    private: PrivateGateways;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
}

declare class OptimizeImageCreateAccessLink {
    private config;
    private urlOpts;
    private imgOpts;
    constructor(config: PinataConfig | undefined, urlOpts: AccessLinkOptions);
    optimizeImage(options: OptimizeImageOptions): OptimizeImageCreateAccessLink;
    then(onfulfilled?: ((value: string) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
}

declare class OptimizeImageGetCid {
    private config;
    private cid;
    private gatewayType?;
    private options;
    constructor(config: PinataConfig | undefined, cid: string, gatewayType?: "ipfs" | "files");
    optimizeImage(options: OptimizeImageOptions): OptimizeImageGetCid;
    then(onfulfilled?: ((value: GetCIDResponse) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
}

declare class PrivateGateways {
    private config;
    constructor(config: PinataConfig | undefined);
    get(cid: string): OptimizeImageGetCid;
    createAccessLink(options: AccessLinkOptions): OptimizeImageCreateAccessLink;
}

declare class PublicGateways {
    private config;
    constructor(config: PinataConfig | undefined);
    get(cid: string): OptimizeImageGetCid;
    convert(url: string, gatewayPrefix?: string): Promise<string>;
}

declare class FilterFiles {
    private config;
    private query;
    private currentPageToken;
    private privacy;
    constructor(config: PinataConfig | undefined, privacy: "private" | "public");
    name(name: string): FilterFiles;
    group(group: string): FilterFiles;
    cid(cid: string): FilterFiles;
    mimeType(mimeType: string): FilterFiles;
    order(order: "ASC" | "DESC"): FilterFiles;
    limit(limit: number): FilterFiles;
    cidPending(cidPending: boolean): FilterFiles;
    keyvalues(keyvalues: Record<string, string>): FilterFiles;
    noGroup(noGroup: boolean): FilterFiles;
    pageToken(pageToken: string): FilterFiles;
    then(onfulfilled?: ((value: FileListResponse) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<FileListItem, void, unknown>;
    all(): Promise<FileListItem[]>;
}

declare class FilterQueue {
    private config;
    private query;
    private currentPageToken;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    cid(cid: string): FilterQueue;
    status(status: "prechecking" | "retrieving" | "expired" | "backfilled" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node"): FilterQueue;
    pageLimit(limit: number): FilterQueue;
    pageToken(pageToken: string): FilterQueue;
    private fetchPage;
    sort(sort: "ASC" | "DSC"): FilterQueue;
    then(onfulfilled?: ((value: PinQueueResponse) => any) | null, onrejected?: ((reason: any) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<PinQueueItem, void, unknown>;
    all(): Promise<PinQueueItem[]>;
}

declare class PublicFiles {
    private config;
    constructor(config?: PinataConfig);
    list(): FilterFiles;
    get(id: string): Promise<FileListItem>;
    delete(files: string[]): Promise<DeleteResponse[]>;
    update(options: UpdateFileOptions): Promise<FileListItem>;
    addSwap(options: SwapCidOptions): Promise<SwapCidResponse>;
    getSwapHistory(options: SwapHistoryOptions): Promise<SwapCidResponse[]>;
    deleteSwap(cid: string): Promise<string>;
    queue(): FilterQueue;
    deletePinRequest(requestId: string): Promise<string>;
}

declare class PrivateFiles {
    private config;
    constructor(config?: PinataConfig);
    list(): FilterFiles;
    get(id: string): Promise<FileListItem>;
    delete(files: string[]): Promise<DeleteResponse[]>;
    update(options: UpdateFileOptions): Promise<FileListItem>;
    addSwap(options: SwapCidOptions): Promise<SwapCidResponse>;
    getSwapHistory(options: SwapHistoryOptions): Promise<SwapCidResponse[]>;
    deleteSwap(cid: string): Promise<string>;
    vectorize(fileId: string): Promise<VectorizeFileResponse>;
    queryVectors(options: VectorizeQuery): Promise<VectorizeQueryResponse | GetCIDResponse>;
    deleteVectors(fileId: string): Promise<VectorizeFileResponse>;
}

declare class Files {
    config: PinataConfig | undefined;
    public: PublicFiles;
    private: PrivateFiles;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
}

declare class UploadBuilder<T> {
    private config;
    private uploadFunction;
    private args;
    private metadata;
    private keys;
    private groupId;
    private vector;
    private uploadUrl;
    private isStreamable;
    private peerAddresses;
    private carFormat;
    constructor(config: PinataConfig | undefined, uploadFunction: (config: PinataConfig | undefined, ...args: any[]) => Promise<T>, ...args: any[]);
    name(name: string): UploadBuilder<T>;
    keyvalues(keyvalues: Record<string, string>): UploadBuilder<T>;
    key(jwt: string): UploadBuilder<T>;
    vectorize(): UploadBuilder<T>;
    url(url: string): UploadBuilder<T>;
    group(groupId: string): UploadBuilder<T>;
    streamable(): UploadBuilder<T>;
    car(): UploadBuilder<T>;
    peerAddress(peerAddresses: string[]): UploadBuilder<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}

declare class PublicUpload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    file(file: File, options?: UploadOptions): UploadBuilder<UploadResponse>;
    fileArray(files: File[], options?: UploadOptions): UploadBuilder<UploadResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<UploadResponse>;
    cid(cid: string, options?: UploadCIDOptions): UploadBuilder<PinByCIDResponse>;
    createSignedURL(options: SignedUploadUrlOptions): Promise<string>;
}

declare class PrivateUpload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    file(file: File, options?: UploadOptions): UploadBuilder<UploadResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<UploadResponse>;
    createSignedURL(options: SignedUploadUrlOptions): Promise<string>;
}

declare class Upload {
    config: PinataConfig | undefined;
    public: PublicUpload;
    private: PrivateUpload;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
}

declare class PublicSignatures {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    add(options: SignatureOptions): Promise<SignatureResponse>;
    get(cid: string): Promise<SignatureResponse>;
    delete(cid: string): Promise<string>;
}

declare class Signatures {
    config: PinataConfig | undefined;
    public: PublicSignatures;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
}

declare class PinataSDK {
    config: PinataConfig | undefined;
    files: Files;
    upload: Upload;
    gateways: Gateways;
    keys: Keys;
    groups: Groups;
    analytics: Analytics;
    signatures: Signatures;
    constructor(config?: PinataConfig);
    setNewHeaders(headers: Record<string, string>): void;
    setNewJwt(jwt: string): void;
    testAuthentication(): Promise<string>;
}

declare function getFileIdFromUrl(url: string): string;

declare const formatConfig: (config: PinataConfig | undefined) => PinataConfig | undefined;

export { AccessLinkOptions, type AnalyticsQuery, type DataEndponts, DeleteResponse, type Endpoints, FileListItem, FileListQuery, FileListResponse, GetCIDResponse, type GetGroupOptions, type GroupCIDOptions, type GroupListResponse, type GroupOptions, type GroupQueryOptions, type GroupResponseItem, JsonBody, type KeyListItem, type KeyListQuery, type KeyListResponse, type KeyOptions, type KeyPermissions, type KeyResponse, OptimizeImageOptions, PinByCIDResponse, PinQueueItem, PinQueueQuery, PinQueueResponse, type PinataConfig, PinataSDK, type PinningEndpoints, type ResourcePermission, type RevokeKeyResponse, type SignatureOptions, type SignatureResponse, SignedUploadUrlOptions, SwapCidOptions, SwapCidResponse, SwapHistoryOptions, type TimeIntervalAnalyticsQuery, type TimeIntervalAnalyticsResponse, type TimePeriodItem, type TopAnalyticsItem, type TopAnalyticsQuery, type TopAnalyticsResponse, UpdateFileOptions, type UpdateGroupFilesResponse, type UpdateGroupOptions, UploadCIDOptions, UploadOptions, UploadResponse, type UserPinnedDataResponse, VectorizeFileResponse, VectorizeQuery, VectorizeQueryResponse, addToGroup, analyticsDateInterval, analyticsTopUsage, convertIPFSUrl, createAccessLink, createGroup, createKey, createSignedUploadURL, deleteFile, deleteFileVectors, deleteGroup, deletePinRequest, deleteSwap, formatConfig, getCid, getFileIdFromUrl, getGroup, listFiles, listGroups, listKeys, pinnedFileCount, queue, removeFromGroup, revokeKeys, swapCid, swapHistory, testAuthentication, totalStorageUsage, updateFile, updateGroup, uploadBase64, uploadCid, uploadFile, uploadFileArray, uploadJson, uploadUrl, vectorizeFile, vectorizeQuery };
