import { NetworkError, AuthenticationError } from '../chunk-ME652TQB.mjs';
export { AuthenticationError, NetworkError, PinataError, ValidationError, convertToDesiredGateway as convert } from '../chunk-ME652TQB.mjs';
import { useState, useRef, useCallback, useEffect } from 'react';

var LARGE_FILE_THRESHOLD = 94371840;
var BASE_CHUNK_SIZE = 262144;
var DEFAULT_CHUNKS = 20 * 10;
var normalizeChunkSize = (size) => {
  if (size < BASE_CHUNK_SIZE) {
    return BASE_CHUNK_SIZE;
  }
  return Math.floor(size / BASE_CHUNK_SIZE) * BASE_CHUNK_SIZE;
};
var useUpload = () => {
  const [progress, setProgress] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [uploadResponse, setUploadResponse] = useState(
    null
  );
  const uploadUrlRef = useRef(null);
  const pausedRef = useRef(false);
  const cancelledRef = useRef(false);
  const uploadOffsetRef = useRef(0);
  const fileRef = useRef(null);
  const headersRef = useRef({});
  const lastResponseHeadersRef = useRef(null);
  const chunkSizeRef = useRef(BASE_CHUNK_SIZE * DEFAULT_CHUNKS);
  const resetState = useCallback(() => {
    setProgress(0);
    setError(null);
    setUploadResponse(null);
    uploadUrlRef.current = null;
    pausedRef.current = false;
    cancelledRef.current = false;
    uploadOffsetRef.current = 0;
    fileRef.current = null;
  }, []);
  const pause = useCallback(() => {
    pausedRef.current = true;
  }, []);
  const resume = useCallback(() => {
    if (pausedRef.current && uploadUrlRef.current && fileRef.current) {
      pausedRef.current = false;
      continueChunkedUpload();
    }
  }, []);
  const cancel = useCallback(() => {
    cancelledRef.current = true;
    setLoading(false);
  }, []);
  const continueChunkedUpload = useCallback(async () => {
    if (!uploadUrlRef.current || !fileRef.current) return;
    try {
      if (cancelledRef.current) {
        resetState();
        return;
      }
      if (pausedRef.current) return;
      const file = fileRef.current;
      const fileSize = file.size;
      const offset = uploadOffsetRef.current;
      const chunkSize = chunkSizeRef.current;
      if (offset >= fileSize) {
        await finalizeUpload();
        return;
      }
      const endOffset = Math.min(offset + chunkSize, fileSize);
      const chunk = file.slice(offset, endOffset);
      const uploadReq = await fetch(uploadUrlRef.current, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/offset+octet-stream",
          "Upload-Offset": offset.toString(),
          ...headersRef.current
        },
        body: chunk
      });
      lastResponseHeadersRef.current = uploadReq.headers;
      if (!uploadReq.ok) {
        const errorData = await uploadReq.text();
        throw new NetworkError(
          `HTTP error during chunk upload: ${errorData}`,
          uploadReq.status,
          {
            error: errorData,
            code: "HTTP_ERROR",
            metadata: { requestUrl: uploadReq.url }
          }
        );
      }
      const newOffset = endOffset;
      uploadOffsetRef.current = newOffset;
      const newProgress = Math.min(newOffset / fileSize * 100, 99.9);
      setProgress(newProgress);
      continueChunkedUpload();
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload"));
      }
      setLoading(false);
    }
  }, [resetState]);
  const finalizeUpload = useCallback(async () => {
    if (!uploadUrlRef.current || !fileRef.current) return;
    try {
      let cid = null;
      if (lastResponseHeadersRef.current) {
        cid = lastResponseHeadersRef.current.get("upload-cid");
      }
      setUploadResponse(cid);
      setProgress(100);
      setLoading(false);
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload finalization"));
      }
      setLoading(false);
    }
  }, []);
  const simpleUpload = async (file, network, url, options) => {
    try {
      const formData = new FormData();
      formData.append("file", file, file.name);
      formData.append("network", network);
      formData.append("name", options?.metadata?.name || file.name);
      if (options?.groupId) {
        formData.append("group_id", options.groupId);
      }
      if (options?.metadata?.keyvalues) {
        formData.append(
          "keyvalues",
          JSON.stringify(options.metadata.keyvalues)
        );
      }
      if (options?.streamable) {
        formData.append("streamable", "true");
      }
      const request = await fetch(url, {
        method: "POST",
        headers: headersRef.current,
        body: formData
      });
      if (!request.ok) {
        const errorData = await request.text();
        if (request.status === 401 || request.status === 403) {
          throw new AuthenticationError(
            `Authentication failed: ${errorData}`,
            request.status,
            {
              error: errorData,
              code: "AUTH_ERROR",
              metadata: { requestUrl: request.url }
            }
          );
        }
        throw new NetworkError(`HTTP error: ${errorData}`, request.status, {
          error: errorData,
          code: "HTTP_ERROR",
          metadata: { requestUrl: request.url }
        });
      }
      const res = await request.json();
      setUploadResponse(res.data);
      setProgress(100);
      setLoading(false);
    } catch (err) {
      if (err instanceof Error) {
        setError(err);
      } else {
        setError(new Error("Unknown error during upload"));
      }
      setLoading(false);
    }
  };
  const upload = useCallback(
    async (file, network, url, options) => {
      try {
        resetState();
        setLoading(true);
        fileRef.current = file;
        const headers = { Source: "sdk/react" };
        headersRef.current = headers;
        if (options?.chunkSize && options.chunkSize > 0) {
          chunkSizeRef.current = normalizeChunkSize(options.chunkSize);
        } else {
          chunkSizeRef.current = BASE_CHUNK_SIZE * DEFAULT_CHUNKS;
        }
        if (file.size <= LARGE_FILE_THRESHOLD) {
          await simpleUpload(file, network, url, options);
          return;
        }
        let metadata = `filename ${btoa(file.name)},filetype ${btoa(file.type)},network ${btoa(network)}`;
        if (options?.groupId) {
          metadata += `,group_id ${btoa(options.groupId)}`;
        }
        if (options?.metadata?.keyvalues) {
          metadata += `,keyvalues ${btoa(JSON.stringify(options.metadata.keyvalues))}`;
        }
        if (options?.streamable) {
          metadata += `,streamable ${btoa("true")}`;
        }
        const urlReq = await fetch(url, {
          method: "POST",
          headers: {
            "Upload-Length": `${file.size}`,
            "Upload-Metadata": metadata,
            ...headers
          }
        });
        if (!urlReq.ok) {
          const errorData = await urlReq.text();
          if (urlReq.status === 401 || urlReq.status === 403) {
            throw new AuthenticationError(
              `Authentication failed: ${errorData}`,
              urlReq.status,
              {
                error: errorData,
                code: "AUTH_ERROR"
              }
            );
          }
          throw new NetworkError("Error initializing upload", urlReq.status, {
            error: errorData,
            code: "HTTP_ERROR"
          });
        }
        const uploadUrl = urlReq.headers.get("Location");
        if (!uploadUrl) {
          throw new NetworkError("Upload URL not provided", urlReq.status, {
            error: "No location header found",
            code: "HTTP_ERROR"
          });
        }
        uploadUrlRef.current = uploadUrl;
        continueChunkedUpload();
      } catch (err) {
        if (err instanceof Error) {
          setError(err);
        } else {
          setError(new Error("Unknown error during upload initialization"));
        }
        setLoading(false);
      }
    },
    [resetState, continueChunkedUpload]
  );
  useEffect(() => {
    return () => {
      cancelledRef.current = true;
    };
  }, []);
  return {
    progress,
    loading,
    error,
    uploadResponse,
    upload,
    pause,
    resume,
    cancel
  };
};

export { useUpload };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map