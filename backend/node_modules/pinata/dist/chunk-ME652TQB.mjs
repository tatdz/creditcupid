// src/utils/custom-errors.ts
var PinataError = class extends Error {
  constructor(message, statusCode, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = "PinataError";
  }
};
var NetworkError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "NetworkError";
  }
};
var AuthenticationError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "AuthenticationError";
  }
};
var ValidationError = class extends PinataError {
  constructor(message, details) {
    super(message, void 0, details);
    this.name = "ValidationError";
  }
};

// src/utils/gateway-tools.ts
function isValidCIDv0(cid) {
  return /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/.test(cid);
}
function isValidCIDv1(cid) {
  return /^b[a-z2-7]{58,}$/.test(cid);
}
function isCID(str) {
  str = str.trim();
  return isValidCIDv0(str) || isValidCIDv1(str);
}
async function containsCID(input) {
  if (typeof input !== "string") {
    throw new Error("Input is not a string");
  }
  const startsWithCID = (str) => {
    const parts = str.split("/");
    return isCID(parts[0]) ? parts[0] : null;
  };
  const directCID = startsWithCID(input);
  if (directCID) {
    return {
      containsCid: true,
      cid: directCID
    };
  }
  let url;
  try {
    url = new URL(input);
  } catch (error) {
    const parts = input.split(/\/|\?/);
    for (const part of parts) {
      const cid = startsWithCID(part);
      if (cid) {
        return {
          containsCid: true,
          cid
        };
      }
    }
    return {
      containsCid: false,
      cid: null
    };
  }
  const subdomains = url.hostname.split(".");
  for (const subdomain of subdomains) {
    if (isCID(subdomain)) {
      return {
        containsCid: true,
        cid: subdomain
      };
    }
  }
  const pathParts = url.pathname.split("/");
  for (const part of pathParts) {
    const cid = startsWithCID(part);
    if (cid) {
      return {
        containsCid: true,
        cid
      };
    }
  }
  return {
    containsCid: false,
    cid: null
  };
}
async function convertToDesiredGateway(sourceUrl, desiredGatewayPrefix) {
  const results = await containsCID(sourceUrl);
  if (results.containsCid !== true) {
    throw new Error("url does not contain CID");
  }
  if (!sourceUrl.startsWith("https") && !sourceUrl.startsWith("ipfs://")) {
    return `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;
  }
  const urlObj = new URL(sourceUrl);
  const path = urlObj.pathname + urlObj.search + urlObj.hash;
  if (sourceUrl.startsWith(`ipfs://${results.cid}`)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  if (sourceUrl.includes(`/ipfs/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (sourceUrl.includes(`/ipns/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (urlObj.hostname.includes(results.cid)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  throw new Error(
    "unsupported URL pattern, please submit a github issue with the URL utilized"
  );
}

// src/utils/resumable.ts
function getFileIdFromUrl(url) {
  const match = url.match(/\/files\/([^\/]+)/);
  if (match && match[1]) {
    return match[1];
  }
  throw new NetworkError("File ID not found in URL", 400, {
    error: "File ID not found in URL",
    code: "HTTP_ERROR",
    metadata: {
      requestUrl: url
    }
  });
}

// src/utils/format-config.ts
var formatConfig = (config) => {
  let gateway = config?.pinataGateway;
  if (config && gateway) {
    if (gateway && !gateway.startsWith("https://")) {
      gateway = `https://${gateway}`;
    }
    config.pinataGateway = gateway;
  }
  return config;
};

export { AuthenticationError, NetworkError, PinataError, ValidationError, containsCID, convertToDesiredGateway, formatConfig, getFileIdFromUrl };
//# sourceMappingURL=chunk-ME652TQB.mjs.map
//# sourceMappingURL=chunk-ME652TQB.mjs.map