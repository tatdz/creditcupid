type FileObject = {
    name: string;
    size: number;
    type: string;
    lastModified: number;
    arrayBuffer: () => Promise<ArrayBuffer>;
};
type JsonBody = Record<string, unknown>;
type PinataMetadata = {
    name?: string;
    keyvalues?: Record<string, string>;
};
type UpdateFileOptions = {
    id: string;
    name?: string;
    keyvalues?: Record<string, string>;
};
type DeleteResponse = {
    id: string;
    status: string;
};
type FileListItem = {
    id: string;
    name: string | null;
    cid: "pending" | string;
    size: number;
    number_of_files: number;
    mime_type: string;
    keyvalues: Record<string, string>;
    group_id: string | null;
    created_at: string;
};
type FileListResponse = {
    files: FileListItem[];
    next_page_token: string;
};
type FileListQuery = {
    name?: string;
    group?: string;
    noGroup?: boolean;
    mimeType?: string;
    cid?: string;
    cidPending?: boolean;
    metadata?: Record<string, string>;
    order?: "ASC" | "DESC";
    limit?: number;
    pageToken?: string;
};
type PinQueueQuery = {
    sort?: "ASC" | "DSC";
    status?: "prechecking" | "retrieving" | "expired" | "backfilled" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node";
    cid?: string;
    limit?: number;
    pageToken?: string;
};
type PinQueueItem = {
    id: string;
    cid?: string;
    ipfs_pin_hash?: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: any;
    host_nodes: string[];
    pin_policy: {
        regions: {
            id: string;
            desiredReplicationCount: number;
        }[];
        version: number;
    };
};
type PinQueueResponse = {
    jobs: PinQueueItem[];
    next_page_token: string;
};
type SwapCidOptions = {
    cid: string;
    swapCid: string;
};
type SwapHistoryOptions = {
    cid: string;
    domain: string;
};
type SwapCidResponse = {
    mapped_cid: string;
    created_at: string;
};
type VectorizeFileResponse = {
    status: boolean;
};
type VectorizeQuery = {
    groupId: string;
    query: string;
    returnFile?: boolean;
};
type VectorQueryMatch = {
    file_id: string;
    cid: string;
    score: number;
};
type VectorizeQueryResponse = {
    count: number;
    matches: VectorQueryMatch[];
};

type ContentType = "application/json" | "application/xml" | "text/plain" | "text/html" | "text/css" | "text/javascript" | "application/javascript" | "image/jpeg" | "image/png" | "image/gif" | "image/svg+xml" | "audio/mpeg" | "audio/ogg" | "video/mp4" | "application/pdf" | "application/octet-stream" | string | null;
type GetCIDResponse = {
    data?: JSON | string | Blob | null;
    contentType: ContentType;
};
type OptimizeImageOptions = {
    width?: number;
    height?: number;
    dpr?: number;
    fit?: "scaleDown" | "contain" | "cover" | "crop" | "pad";
    gravity?: "auto" | "side" | string;
    quality?: number;
    format?: "auto" | "webp";
    animation?: boolean;
    sharpen?: number;
    onError?: boolean;
    metadata?: "keep" | "copyright" | "none";
};
type AccessLinkOptions = {
    cid: string;
    date?: number;
    expires: number;
    gateway?: string;
};
type ContainsCIDResponse = {
    containsCid: boolean;
    cid: string | null;
};

type UploadResponse = {
    id: string;
    name: string;
    cid: string;
    size: number;
    created_at: string;
    number_of_files: number;
    mime_type: string;
    group_id: string | null;
    keyvalues: {
        [key: string]: string;
    };
    vectorized: boolean;
    network: string;
};
type UploadOptions = {
    metadata?: PinataMetadata;
    keys?: string;
    groupId?: string;
    vectorize?: boolean;
    url?: string;
    streamable?: boolean;
    peerAddresses?: string[];
    car?: boolean;
};
type SignedUploadUrlOptions = {
    date?: number;
    expires: number;
    groupId?: string;
    name?: string;
    keyvalues?: Record<string, string>;
    vectorize?: boolean;
    maxFileSize?: number;
    mimeTypes?: string[];
    streamable?: boolean;
    car?: boolean;
};
type UploadCIDOptions = {
    metadata?: PinataMetadata;
    peerAddresses?: string[];
    keys?: string;
    groupId?: string;
};
type PinByCIDResponse = {
    id: string;
    cid: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: Record<string, any> | null;
    host_nodes: string[] | null;
    group_id: string | null;
};

interface ErrorDetails {
    error?: string;
    code?: string;
    metadata?: Record<string, any>;
}
declare class PinataError extends Error {
    statusCode?: number | undefined;
    details?: ErrorDetails | undefined;
    constructor(message: string, statusCode?: number | undefined, details?: ErrorDetails | undefined);
}
declare class NetworkError extends PinataError {
    constructor(message: string, statusCode?: number, details?: ErrorDetails);
}
declare class AuthenticationError extends PinataError {
    constructor(message: string, statusCode?: number, details?: ErrorDetails);
}
declare class ValidationError extends PinataError {
    constructor(message: string, details?: ErrorDetails);
}

declare function containsCID(input: string): Promise<ContainsCIDResponse>;
declare function convertToDesiredGateway(sourceUrl: string, desiredGatewayPrefix: string | undefined): Promise<string>;

export { type AccessLinkOptions as A, type ContentType as C, type DeleteResponse as D, type FileListQuery as F, type GetCIDResponse as G, type JsonBody as J, NetworkError as N, type OptimizeImageOptions as O, type PinQueueQuery as P, type SwapCidOptions as S, type UpdateFileOptions as U, type VectorizeFileResponse as V, type FileListResponse as a, type SwapCidResponse as b, type SwapHistoryOptions as c, type FileListItem as d, type VectorizeQuery as e, type VectorizeQueryResponse as f, type PinQueueResponse as g, type UploadOptions as h, type UploadResponse as i, type SignedUploadUrlOptions as j, type UploadCIDOptions as k, type PinByCIDResponse as l, type PinQueueItem as m, type FileObject as n, type PinataMetadata as o, type VectorQueryMatch as p, type ContainsCIDResponse as q, PinataError as r, AuthenticationError as s, ValidationError as t, containsCID as u, convertToDesiredGateway as v };
