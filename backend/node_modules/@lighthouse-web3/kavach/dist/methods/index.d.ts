import { generate } from "./generate";
import { getJWT } from "./getJWT";
import { getAuthMessage } from "./getAuthMessage";
import { recoverKey } from "./recoverKey";
import { recoverShards } from "./recoverShards";
import { saveShards } from "./saveShards";
import { shardKey } from "./shardKey";
import { revokeAccess } from "./revokeAccess";
import { accessControl } from "./accessControl";
import { shareToAddress } from "./shareToAddress";
import { transferOwnership } from "./transferOwnership";
import { getAccessCondition } from "./getAccessCondition";
export { generate, getJWT, getAuthMessage, recoverShards, revokeAccess, recoverKey, saveShards, shardKey, accessControl, shareToAddress, transferOwnership, getAccessCondition };
declare const _default: {
    generate: (threshold?: number, keyCount?: number) => Promise<import("../types").GeneratedKey>;
    getJWT: (address: string, payload: string, useAsRefreshToken?: boolean, chain?: string) => Promise<{
        JWT: any;
        refreshToken: any;
        error: null;
    } | {
        JWT: null;
        error: string;
        refreshToken?: undefined;
    }>;
    getAuthMessage: (address: string) => Promise<import("../types").AuthMessage>;
    recoverShards: (address: string, cid: string, auth_token: string, numOfShards?: number, dynamicData?: {}) => Promise<import("../types").RecoverShards>;
    revokeAccess: (address: string, cid: string, auth_token: string, revokeTo: string[]) => Promise<import("../types").LightHouseSDKResponse>;
    recoverKey: (keyShards: import("../types").KeyShard[]) => Promise<{
        masterKey: any;
        error: null;
    } | {
        masterKey: null;
        error: string;
    }>;
    saveShards: (address: string, cid: string, auth_token: string, keyShards: import("../types").KeyShard[], shareTo?: string[]) => Promise<{
        isSuccess: boolean;
        error: any;
    } | {
        isSuccess: any;
        error: null;
    }>;
    shardKey: (key: string, threshold?: number, keyCount?: number) => Promise<{
        isShardable: boolean;
        keyShards: {
            key: any;
            index: any;
        }[];
    }>;
    accessControl: (address: string, cid: string, auth_token: string, conditions: import("../types").Condition[], aggregator?: string | undefined, chainType?: import("../types").ChainType, keyShards?: import("../types").KeyShard[], decryptionType?: import("../types").DecryptionType) => Promise<import("../types").LightHouseSDKResponse>;
    shareToAddress: (address: string, cid: string, auth_token: string, shareTo: string[]) => Promise<import("../types").LightHouseSDKResponse>;
    transferOwnership: (address: string, cid: string, newOwner: string, auth_token: string, resetSharedTo?: boolean) => Promise<import("../types").LightHouseSDKResponse>;
    getAccessCondition: (cid: string) => Promise<{
        data: import("../types").IGetAccessCondition;
    }>;
};
export default _default;
