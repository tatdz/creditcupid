"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lighthouse_config_1 = require("../../../../lighthouse.config");
const kavach_1 = require("@lighthouse-web3/kavach");
const encryptionNode_1 = require("../../encryptionNode");
const node_1 = require("../../../upload/files/node");
const util_1 = require("../../../utils/util");
exports.default = async (sourcePath, apiKey, publicKey, auth_token, cidVersion) => {
    const fs = eval('require')('fs-extra');
    const token = 'Bearer ' + apiKey;
    const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode +
        `/api/v0/add?wrap-with-directory=false&cid-version=${cidVersion}`;
    const stats = fs.lstatSync(sourcePath);
    if (stats.isFile()) {
        try {
            const formData = new FormData();
            const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();
            const fileData = fs.readFileSync(sourcePath);
            const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);
            const blob = new Blob([Buffer.from(encryptedData)]);
            formData.append('file', blob, sourcePath.replace(/^.*[\\/]/, ''));
            const response = await (0, util_1.fetchWithTimeout)(endpoint, {
                method: 'POST',
                body: formData,
                timeout: 7200000,
                headers: {
                    Encryption: 'true',
                    Authorization: token,
                },
            });
            if (!response.ok) {
                const res = await response.json();
                throw new Error(res.error);
            }
            const responseData = (await response.json());
            const { error } = await (0, kavach_1.saveShards)(publicKey, responseData[0].Hash, auth_token, keyShards);
            if (error) {
                throw new Error('Error encrypting file');
            }
            return { data: responseData };
        }
        catch (error) {
            throw new Error(error);
        }
    }
    else {
        const files = await (0, node_1.walk)(sourcePath);
        const formData = new FormData();
        if (files.length > 1 && auth_token.startsWith('0x')) {
            throw new Error(JSON.stringify(`auth_token must be a JWT`));
        }
        let keyMap = {};
        await Promise.all(files.map(async (file) => {
            const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();
            const fileData = fs.readFileSync(file);
            const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);
            const filename = file.slice(sourcePath.length + 1).replaceAll('/', '-');
            formData.append('file', new Blob([encryptedData]), filename);
            keyMap = { ...keyMap, [filename]: keyShards };
            return [filename, keyShards];
        }));
        const response = await (0, util_1.fetchWithTimeout)(endpoint, {
            method: 'POST',
            body: formData,
            timeout: 7200000,
            headers: {
                Encryption: 'true',
                Authorization: token,
            },
        });
        if (!response.ok) {
            const res = await response.json();
            throw new Error(res.error);
        }
        const responseText = await response.text();
        let jsondata = [];
        const match = responseText.match(/\[.*\]$/s);
        if (match) {
            jsondata = JSON.parse(match[0]);
        }
        else {
            throw new Error('No JSON array found in response');
        }
        const savedKey = await Promise.all(jsondata.map(async (data) => {
            return (0, kavach_1.saveShards)(publicKey, data.Hash, auth_token, keyMap[data.Name]);
        }));
        savedKey.forEach((_savedKey) => {
            if (!_savedKey.isSuccess) {
                throw new Error(JSON.stringify(_savedKey));
            }
        });
        return { data: jsondata };
    }
};
