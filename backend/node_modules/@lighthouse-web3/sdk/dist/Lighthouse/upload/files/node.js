"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.walk = void 0;
const basePathConvert_1 = __importDefault(require("../../utils/basePathConvert"));
const lighthouse_config_1 = require("../../../lighthouse.config");
const util_1 = require("../../utils/util");
async function walk(dir) {
    const { readdir, stat } = eval(`require`)('fs-extra');
    let results = [];
    const files = await readdir(dir);
    for (const file of files) {
        const filePath = `${dir}/${file}`;
        const _stat = await stat(filePath);
        if (_stat.isDirectory()) {
            results = results.concat(await walk(filePath));
        }
        else {
            results.push(filePath);
        }
    }
    return results;
}
exports.walk = walk;
exports.default = async (sourcePath, apiKey, cidVersion, uploadProgressCallback) => {
    const { createReadStream, lstatSync } = eval(`require`)('fs-extra');
    const path = eval(`require`)('path');
    const token = 'Bearer ' + apiKey;
    const stats = lstatSync(sourcePath);
    try {
        const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode +
            `/api/v0/add?wrap-with-directory=false&cid-version=${cidVersion}`;
        const boundary = '----WebKitFormBoundary' + Math.random().toString(16).substr(2);
        const headers = {
            Authorization: token,
        };
        if (stats.isFile()) {
            const stream = createReadStream(sourcePath);
            const streamData = {
                boundary,
                files: [
                    {
                        stream,
                        filename: path.basename(sourcePath),
                        size: stats.size,
                    },
                ],
            };
            const response = await (0, util_1.fetchWithDirectStream)(endpoint, {
                method: 'POST',
                headers,
                timeout: 7200000,
                onProgress: uploadProgressCallback
                    ? (data) => uploadProgressCallback(data)
                    : undefined,
            }, streamData);
            return response;
        }
        else {
            // Handle directory upload
            const files = await walk(sourcePath);
            const createStreamData = () => ({
                boundary,
                files: files.map((file) => {
                    const fileStats = lstatSync(file);
                    return {
                        stream: createReadStream(file),
                        filename: (0, basePathConvert_1.default)(sourcePath, file),
                        size: fileStats.size,
                    };
                }),
            });
            const streamData = createStreamData();
            const response = await (0, util_1.fetchWithDirectStream)(endpoint, {
                method: 'POST',
                headers,
                timeout: 7200000,
                onProgress: uploadProgressCallback
                    ? (data) => uploadProgressCallback(data)
                    : undefined,
            }, streamData);
            return response;
        }
    }
    catch (error) {
        throw new Error(error);
    }
};
