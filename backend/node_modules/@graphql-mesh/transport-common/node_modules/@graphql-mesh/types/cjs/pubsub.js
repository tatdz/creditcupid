"use strict";
var _MeshFromHivePubSub_pubsub, _MeshFromHivePubSub_subs;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeshFromHivePubSub = void 0;
exports.isHivePubSub = isHivePubSub;
exports.toMeshPubSub = toMeshPubSub;
const tslib_1 = require("tslib");
const utils_1 = require("@graphql-tools/utils");
const repeater_1 = require("@repeaterjs/repeater");
const disposablestack_1 = require("@whatwg-node/disposablestack");
/**
 * Converts the {@link PubSub Hive PubSub interface} to the legacy {@link MeshPubSub}
 * Please avoid using this class directly because it will be completely removed in
 * the future, instead migrate your project to use the {@link PubSub new interface}.
 *
 * @deprecated This class is deprecated and will be removed in the future. Implement and use the new {@link HivePubSub Hive PubSub interface} instead.
 */
class MeshFromHivePubSub {
    constructor(pubsub) {
        _MeshFromHivePubSub_pubsub.set(this, void 0);
        _MeshFromHivePubSub_subs.set(this, new Map());
        tslib_1.__classPrivateFieldSet(this, _MeshFromHivePubSub_pubsub, pubsub, "f");
    }
    static from(pubsub) {
        if (!pubsub)
            return undefined;
        return new MeshFromHivePubSub(pubsub);
    }
    publish(triggerName, payload) {
        const publishing = tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").publish(triggerName, payload);
        if ((0, utils_1.isPromise)(publishing)) {
            publishing.catch(err => {
                console.error(`Failed to publish to ${triggerName}`, err);
            });
        }
    }
    subscribe(triggerName, onMessage) {
        const subId = Math.floor(Math.random() * 100_000_000);
        const unsub = tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").subscribe(triggerName, onMessage);
        tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").set(subId, { triggerName, unsubscribe: unsub });
        if ((0, utils_1.isPromise)(unsub)) {
            unsub.catch(err => {
                tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").delete(subId);
                // TODO: what to do? is just logging ok?
                console.error(`Failed to subscribe to ${triggerName}`, err);
            });
        }
        return subId;
    }
    unsubscribe(subId) {
        const { unsubscribe } = tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").get(subId) || {};
        if (!unsubscribe) {
            return;
        }
        tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").delete(subId);
        if ((0, utils_1.isPromise)(unsubscribe)) {
            unsubscribe
                .then(unsub => {
                try {
                    const unsubbed = unsub();
                    if ((0, utils_1.isPromise)(unsubbed)) {
                        unsubbed.catch(err => {
                            console.error(`Failed to finish unsubscribe from ${subId}`, err);
                        });
                    }
                }
                catch (err) {
                    console.error(`Failed to finish unsubscribe from ${subId}`, err);
                }
            })
                .catch(err => {
                console.error(`Failed to start unsubscribe from ${subId}`, err);
            });
        }
        else {
            const unsubbed = unsubscribe();
            if ((0, utils_1.isPromise)(unsubbed)) {
                unsubbed.catch(err => {
                    console.error(`Failed to finish unsubscribe from ${subId}`, err);
                });
            }
        }
    }
    getEventNames() {
        // NOTE that the HivePubSub's subscriberTopics can be asynchronous
        // but we're not tracking that here because we cant
        return new Set(
        // get only distinct trigger names
        Array.from(tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").values(), ({ triggerName }) => triggerName));
    }
    asyncIterator(triggerName) {
        return new repeater_1.Repeater(async (push, stop) => {
            const subId = this.subscribe(triggerName, push);
            await stop;
            this.unsubscribe(subId);
        });
    }
    dispose() {
        return tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").dispose();
    }
    [(_MeshFromHivePubSub_pubsub = new WeakMap(), _MeshFromHivePubSub_subs = new WeakMap(), disposablestack_1.DisposableSymbols.asyncDispose)]() {
        return tslib_1.__classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").dispose();
    }
}
exports.MeshFromHivePubSub = MeshFromHivePubSub;
/**
 * Checks whether the provided {@link pubsub} is a {@link HivePubSub}. It is only
 * accurate when dealing with `@graphql-hive/pubsub` v2 and above.
 */
function isHivePubSub(pubsub) {
    // HivePubSub does not have asyncIterator method. this only applies for @graphql-hive/pubsub v2+
    return pubsub != null && !('asyncIterator' in pubsub);
}
const meshForHibePubSub = new WeakMap();
function toMeshPubSub(pubsub) {
    if (isHivePubSub(pubsub)) {
        let hivePubsub = meshForHibePubSub.get(pubsub);
        if (hivePubsub) {
            return hivePubsub;
        }
        hivePubsub = MeshFromHivePubSub.from(pubsub);
        meshForHibePubSub.set(pubsub, hivePubsub);
        return hivePubsub;
    }
    return pubsub;
}
