var _MeshFromHivePubSub_pubsub, _MeshFromHivePubSub_subs;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { isPromise } from '@graphql-tools/utils';
import { Repeater } from '@repeaterjs/repeater';
import { DisposableSymbols } from '@whatwg-node/disposablestack';
/**
 * Converts the {@link PubSub Hive PubSub interface} to the legacy {@link MeshPubSub}
 * Please avoid using this class directly because it will be completely removed in
 * the future, instead migrate your project to use the {@link PubSub new interface}.
 *
 * @deprecated This class is deprecated and will be removed in the future. Implement and use the new {@link HivePubSub Hive PubSub interface} instead.
 */
export class MeshFromHivePubSub {
    constructor(pubsub) {
        _MeshFromHivePubSub_pubsub.set(this, void 0);
        _MeshFromHivePubSub_subs.set(this, new Map());
        __classPrivateFieldSet(this, _MeshFromHivePubSub_pubsub, pubsub, "f");
    }
    static from(pubsub) {
        if (!pubsub)
            return undefined;
        return new MeshFromHivePubSub(pubsub);
    }
    publish(triggerName, payload) {
        const publishing = __classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").publish(triggerName, payload);
        if (isPromise(publishing)) {
            publishing.catch(err => {
                console.error(`Failed to publish to ${triggerName}`, err);
            });
        }
    }
    subscribe(triggerName, onMessage) {
        const subId = Math.floor(Math.random() * 100_000_000);
        const unsub = __classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").subscribe(triggerName, onMessage);
        __classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").set(subId, { triggerName, unsubscribe: unsub });
        if (isPromise(unsub)) {
            unsub.catch(err => {
                __classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").delete(subId);
                // TODO: what to do? is just logging ok?
                console.error(`Failed to subscribe to ${triggerName}`, err);
            });
        }
        return subId;
    }
    unsubscribe(subId) {
        const { unsubscribe } = __classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").get(subId) || {};
        if (!unsubscribe) {
            return;
        }
        __classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").delete(subId);
        if (isPromise(unsubscribe)) {
            unsubscribe
                .then(unsub => {
                try {
                    const unsubbed = unsub();
                    if (isPromise(unsubbed)) {
                        unsubbed.catch(err => {
                            console.error(`Failed to finish unsubscribe from ${subId}`, err);
                        });
                    }
                }
                catch (err) {
                    console.error(`Failed to finish unsubscribe from ${subId}`, err);
                }
            })
                .catch(err => {
                console.error(`Failed to start unsubscribe from ${subId}`, err);
            });
        }
        else {
            const unsubbed = unsubscribe();
            if (isPromise(unsubbed)) {
                unsubbed.catch(err => {
                    console.error(`Failed to finish unsubscribe from ${subId}`, err);
                });
            }
        }
    }
    getEventNames() {
        // NOTE that the HivePubSub's subscriberTopics can be asynchronous
        // but we're not tracking that here because we cant
        return new Set(
        // get only distinct trigger names
        Array.from(__classPrivateFieldGet(this, _MeshFromHivePubSub_subs, "f").values(), ({ triggerName }) => triggerName));
    }
    asyncIterator(triggerName) {
        return new Repeater(async (push, stop) => {
            const subId = this.subscribe(triggerName, push);
            await stop;
            this.unsubscribe(subId);
        });
    }
    dispose() {
        return __classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").dispose();
    }
    [(_MeshFromHivePubSub_pubsub = new WeakMap(), _MeshFromHivePubSub_subs = new WeakMap(), DisposableSymbols.asyncDispose)]() {
        return __classPrivateFieldGet(this, _MeshFromHivePubSub_pubsub, "f").dispose();
    }
}
/**
 * Checks whether the provided {@link pubsub} is a {@link HivePubSub}. It is only
 * accurate when dealing with `@graphql-hive/pubsub` v2 and above.
 */
export function isHivePubSub(pubsub) {
    // HivePubSub does not have asyncIterator method. this only applies for @graphql-hive/pubsub v2+
    return pubsub != null && !('asyncIterator' in pubsub);
}
const meshForHibePubSub = new WeakMap();
export function toMeshPubSub(pubsub) {
    if (isHivePubSub(pubsub)) {
        let hivePubsub = meshForHibePubSub.get(pubsub);
        if (hivePubsub) {
            return hivePubsub;
        }
        hivePubsub = MeshFromHivePubSub.from(pubsub);
        meshForHibePubSub.set(pubsub, hivePubsub);
        return hivePubsub;
    }
    return pubsub;
}
