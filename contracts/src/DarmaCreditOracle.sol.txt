// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "forge-std/console.sol";
import "pyth-sdk-solidity/PythStructs.sol";
import "pyth-sdk-solidity/IPyth.sol";

/**
 * @title DarmaCreditOracle
 * @dev Main credit oracle contract that integrates with Pyth price feeds
 * and computes credit scores based on cross-chain protocol interactions
 */
contract DarmaCreditOracle {
    address public owner;
    IPyth public pyth;
    
    struct CreditScore {
        uint256 score;
        uint256 lastUpdated;
        uint256 confidence;
        string tier;
        uint256 crossChainActivity;
        uint256 aaveRepayments;
        uint256 morphoRepayments;
        uint256 totalBorrowed;
        uint256 totalRepaid;
        uint256 assetDiversity;
    }
    
    // Pyth Price Feed IDs
    bytes32 public constant ETH_FEED_ID = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;
    bytes32 public constant AAVE_FEED_ID = 0x56a0a4e8a17eac26406bf0d19ec2f494db0405f61ae4f0fe217dd097ab85dd1e;
    bytes32 public constant USDC_FEED_ID = 0x986b5e1e1755e3c2440e960477f25201b0a8bbd4e4fae5f5d0de7e39a5688a40;
    bytes32 public constant DAI_FEED_ID = 0x22215aa89acfb2e63b0cdda1f4e7dddcea250be07e8a051985f4b3b8a1c257f0;
    bytes32 public constant WBTC_FEED_ID = 0xdeb288f737066589598e9214e782fa5a8ed689e8c0f595317aef0e43f620ee2c;
    
    mapping(address => CreditScore) public creditScores;
    mapping(bytes32 => bool) public supportedPriceFeeds;
    
    event CreditScoreUpdated(address indexed borrower, uint256 score, string tier);
    event PriceFeedUpdated(bytes32 feedId, int64 price, uint256 confidence);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    constructor(address _pyth) {
        owner = msg.sender;
        pyth = IPyth(_pyth);
        
        // Initialize supported Pyth price feeds
        supportedPriceFeeds[ETH_FEED_ID] = true;
        supportedPriceFeeds[AAVE_FEED_ID] = true;
        supportedPriceFeeds[USDC_FEED_ID] = true;
        supportedPriceFeeds[DAI_FEED_ID] = true;
        supportedPriceFeeds[WBTC_FEED_ID] = true;
    }
    
    /**
     * @dev Update credit score for a borrower with protocol-specific data
     */
    function updateCreditScore(
        address _borrower,
        uint256 _score,
        uint256 _crossChainActivity,
        uint256 _aaveRepayments,
        uint256 _morphoRepayments,
        uint256 _totalBorrowed,
        uint256 _totalRepaid,
        uint256 _assetDiversity,
        bytes[] calldata _priceUpdateData
    ) external payable onlyOwner {
        // Update Pyth prices
        uint256 fee = pyth.getUpdateFee(_priceUpdateData);
        pyth.updatePriceFeeds{value: fee}(_priceUpdateData);
        
        // Calculate tier based on comprehensive scoring
        string memory tier = calculateTier(_score, _crossChainActivity);
        
        creditScores[_borrower] = CreditScore({
            score: _score,
            lastUpdated: block.timestamp,
            confidence: _crossChainActivity,
            tier: tier,
            crossChainActivity: _crossChainActivity,
            aaveRepayments: _aaveRepayments,
            morphoRepayments: _morphoRepayments,
            totalBorrowed: _totalBorrowed,
            totalRepaid: _totalRepaid,
            assetDiversity: _assetDiversity
        });
        
        emit CreditScoreUpdated(_borrower, _score, tier);
    }
    
    /**
     * @dev Calculate credit tier based on score and cross-chain activity
     */
    function calculateTier(uint256 _score, uint256 _crossChainActivity) internal pure returns (string memory) {
        if (_score >= 800 && _crossChainActivity >= 3) return "AA";
        if (_score >= 750 && _crossChainActivity >= 2) return "A+";
        if (_score >= 700) return "A";
        if (_score >= 650) return "B+";
        if (_score >= 600) return "B";
        if (_score >= 550) return "C+";
        if (_score >= 500) return "C";
        return "D";
    }
    
    /**
     * @dev Get credit score for a borrower
     */
    function getCreditScore(address _borrower) external view returns (CreditScore memory) {
        return creditScores[_borrower];
    }
    
    /**
     * @dev Calculate borrowing limit based on credit score and collateral
     */
    function calculateBorrowingLimit(
        address _borrower,
        bytes32 _collateralFeedId,
        uint256 _collateralAmount
    ) external view returns (uint256) {
        CreditScore memory score = creditScores[_borrower];
        require(score.score > 0, "No credit score available");
        require(supportedPriceFeeds[_collateralFeedId], "Unsupported price feed");
        
        PythStructs.Price memory price = pyth.getPrice(_collateralFeedId);
        uint256 collateralValue = (_collateralAmount * uint256(price.price)) / 10 ** uint256(-price.expo);
        
        // Dynamic LTV based on credit tier
        uint256 baseLTV = getLTVForTier(score.tier);
        
        return (collateralValue * baseLTV) / 100;
    }
    
    /**
     * @dev Get LTV percentage based on credit tier
     */
    function getLTVForTier(string memory _tier) internal pure returns (uint256) {
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("AA"))) return 80;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("A+"))) return 75;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("A"))) return 70;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("B+"))) return 65;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("B"))) return 60;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("C+"))) return 55;
        if (keccak256(abi.encodePacked(_tier)) == keccak256(abi.encodePacked("C"))) return 50;
        return 40;
    }
    
    /**
     * @dev Get current collateral price from Pyth
     */
    function getCollateralPrice(bytes32 _feedId) external view returns (int64, uint256) {
        require(supportedPriceFeeds[_feedId], "Unsupported price feed");
        PythStructs.Price memory price = pyth.getPrice(_feedId);
        return (price.price, price.conf);
    }
    
    /**
     * @dev Update owner address
     */
    function transferOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid owner address");
        owner = _newOwner;
    }
}