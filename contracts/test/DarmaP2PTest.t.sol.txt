// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "forge-std/Test.sol";
import "../src/DarmaP2PLending.sol";
import "../src/DarmaCreditOracle.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10**18);
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract DarmaP2PTest is Test {
    DarmaP2PLending public p2pLending;
    DarmaCreditOracle public creditOracle;
    MockERC20 public usdc;
    
    address owner = address(0x1);
    address borrower = address(0x2);
    address lender = address(0x3);
    address pythOracle = address(0x4);
    
    bytes32 constant ETH_FEED_ID = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;
    
    function setUp() public {
        vm.startPrank(owner);
        
        // Deploy mock tokens
        usdc = new MockERC20("USDC", "USDC");
        
        // Deploy credit oracle
        creditOracle = new DarmaCreditOracle(pythOracle);
        
        // Deploy P2P lending
        p2pLending = new DarmaP2PLending(address(creditOracle));
        
        // Add supported tokens
        p2pLending.addSupportedToken(address(usdc));
        
        vm.stopPrank();
        
        // Fund test accounts
        usdc.mint(borrower, 10000 * 10**18);
        usdc.mint(lender, 10000 * 10**18);
    }
    
    function testCreateLoanRequest() public {
        vm.startPrank(borrower);
        
        // Approve collateral
        usdc.approve(address(p2pLending), 1000 * 10**18);
        
        // Mock credit score update (in real scenario, this would be done by owner)
        bytes[] memory priceUpdateData = new bytes[](0);
        
        // Create loan request
        uint256 loanId = p2pLending.createLoanRequest(
            address(usdc),
            500 * 10**18, // principal
            1000 * 10**18, // collateral
            90 days,
            ETH_FEED_ID,
            "QmTestIPFSHash123",
            priceUpdateData
        );
        
        assertEq(loanId, 0, "Loan ID should be 0");
        assertEq(usdc.balanceOf(address(p2pLending)), 1000 * 10**18, "Collateral should be locked");
        
        vm.stopPrank();
    }
    
    function testCreateLoanOffer() public {
        vm.startPrank(lender);
        
        uint256 offerId = p2pLending.createLoanOffer(
            address(usdc),
            1000 * 10**18, // maxAmount
            600, // minScore
            70, // maxLTV
            800, // interestRate (8%)
            180 days, // maxDuration
            "QmOfferTermsHash456"
        );
        
        assertEq(offerId, 0, "Offer ID should be 0");
        
        vm.stopPrank();
    }
    
    function testFundLoan() public {
        // First create loan request
        vm.startPrank(borrower);
        usdc.approve(address(p2pLending), 1000 * 10**18);
        bytes[] memory priceUpdateData = new bytes[](0);
        
        uint256 loanId = p2pLending.createLoanRequest(
            address(usdc),
            500 * 10**18,
            1000 * 10**18,
            90 days,
            ETH_FEED_ID,
            "QmTestIPFSHash123",
            priceUpdateData
        );
        vm.stopPrank();
        
        // Create loan offer
        vm.startPrank(lender);
        uint256 offerId = p2pLending.createLoanOffer(
            address(usdc),
            1000 * 10**18,
            600,
            70,
            800,
            180 days,
            "QmOfferTermsHash456"
        );
        
        // Fund the loan
        usdc.approve(address(p2pLending), 500 * 10**18);
        p2pLending.fundLoan(loanId, offerId);
        
        // Check balances
        assertEq(usdc.balanceOf(borrower), 500 * 10**18, "Borrower should receive principal");
        assertEq(usdc.balanceOf(address(p2pLending)), 1500 * 10**18, "Contract should hold collateral + principal");
        
        vm.stopPrank();
    }
    
    function testRepayLoan() public {
        // Setup loan
        vm.startPrank(borrower);
        usdc.approve(address(p2pLending), 1000 * 10**18);
        bytes[] memory priceUpdateData = new bytes[](0);
        
        uint256 loanId = p2pLending.createLoanRequest(
            address(usdc),
            500 * 10**18,
            1000 * 10**18,
            90 days,
            ETH_FEED_ID,
            "QmTestIPFSHash123",
            priceUpdateData
        );
        vm.stopPrank();
        
        vm.startPrank(lender);
        uint256 offerId = p2pLending.createLoanOffer(
            address(usdc),
            1000 * 10**18,
            600,
            70,
            800,
            180 days,
            "QmOfferTermsHash456"
        );
        
        usdc.approve(address(p2pLending), 500 * 10**18);
        p2pLending.fundLoan(loanId, offerId);
        vm.stopPrank();
        
        // Repay loan
        vm.startPrank(borrower);
        uint256 repaymentAmount = p2pLending.calculateRepaymentAmount(500 * 10**18, 800);
        usdc.approve(address(p2pLending), repaymentAmount);
        p2pLending.repayLoan(loanId);
        
        // Check final balances
        assertEq(usdc.balanceOf(borrower), 1000 * 10**18 - repaymentAmount, "Borrower should pay back loan with interest");
        assertEq(usdc.balanceOf(lender), 10000 * 10**18 - 500 * 10**18 + repaymentAmount, "Lender should receive principal + interest");
        
        vm.stopPrank();
    }
    
    function testLoanLiquidation() public {
        // Setup loan
        vm.startPrank(borrower);
        usdc.approve(address(p2pLending), 1000 * 10**18);
        bytes[] memory priceUpdateData = new bytes[](0);
        
        uint256 loanId = p2pLending.createLoanRequest(
            address(usdc),
            500 * 10**18,
            1000 * 10**18,
            7 days, // Short duration for testing
            ETH_FEED_ID,
            "QmTestIPFSHash123",
            priceUpdateData
        );
        vm.stopPrank();
        
        vm.startPrank(lender);
        uint256 offerId = p2pLending.createLoanOffer(
            address(usdc),
            1000 * 10**18,
            600,
            70,
            800,
            180 days,
            "QmOfferTermsHash456"
        );
        
        usdc.approve(address(p2pLending), 500 * 10**18);
        p2pLending.fundLoan(loanId, offerId);
        vm.stopPrank();
        
        // Fast forward past due date
        vm.warp(block.timestamp + 8 days);
        
        // Liquidate loan
        vm.startPrank(address(0x5)); // Any address can liquidate
        p2pLending.liquidateLoan(loanId);
        
        // Check that lender received collateral
        assertEq(usdc.balanceOf(lender), 10000 * 10**18 - 500 * 10**18 + 1000 * 10**18, "Lender should receive collateral");
        
        vm.stopPrank();
    }
    
    function testOnlyOwnerFunctions() public {
        vm.startPrank(borrower);
        
        // Should fail - only owner can add tokens
        vm.expectRevert("Only owner can call this function");
        p2pLending.addSupportedToken(address(0x123));
        
        // Should fail - only owner can set protocol fee
        vm.expectRevert("Only owner can call this function");
        p2pLending.setProtocolFee(50);
        
        vm.stopPrank();
    }
    
    function testInvalidOperations() public {
        vm.startPrank(borrower);
        
        // Try to create loan with unsupported token
        bytes[] memory priceUpdateData = new bytes[](0);
        
        vm.expectRevert("Token not supported");
        p2pLending.createLoanRequest(
            address(0x123),
            500 * 10**18,
            1000 * 10**18,
            90 days,
            ETH_FEED_ID,
            "QmTestIPFSHash123",
            priceUpdateData
        );
        
        vm.stopPrank();
    }
}