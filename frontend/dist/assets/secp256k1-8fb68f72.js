import{z as ke,C as Ce,D as ze,E as Ve,F as re,G as Pe,J as Me,K as je,L as we,O as _t}from"./index-e1e3b787.js";class ge extends ke{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ce(n);const r=ze(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),Ve(i)}update(n){return re(this),this.iHash.update(n),this}digestInto(n){re(this),Pe(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:c,outputLen:f}=this;return n=n,n.finished=s,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const me=(t,n,e)=>new ge(t,n).update(e).digest();me.create=(t,n)=>new ge(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=BigInt(0),Kt=BigInt(1);function xt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function nt(t){if(!xt(t))throw new Error("Uint8Array expected")}function mt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function At(t){const n=t.toString(16);return n.length&1?"0"+n:n}function ye(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Xt:BigInt("0x"+t)}const be=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ke=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function yt(t){if(nt(t),be)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ke[t[e]];return n}const Q={_0:48,_9:57,A:65,F:70,a:97,f:102};function oe(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q.A&&t<=Q.F)return t-(Q.A-10);if(t>=Q.a&&t<=Q.f)return t-(Q.a-10)}function It(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(be)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const c=oe(t.charCodeAt(i)),f=oe(t.charCodeAt(i+1));if(c===void 0||f===void 0){const o=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+i)}r[s]=c*16+f}return r}function $(t){return ye(yt(t))}function Ee(t){return nt(t),ye(yt(Uint8Array.from(t).reverse()))}function ft(t,n){return It(t.toString(16).padStart(n*2,"0"))}function pe(t,n){return ft(t,n).reverse()}function z(t,n,e){let r;if(typeof n=="string")try{r=It(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(xt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function D(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];nt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const i=t[r];e.set(i,s),s+=i.length}return e}function Qt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Zt=t=>typeof t=="bigint"&&Xt<=t;function bt(t,n,e){return Zt(t)&&Zt(n)&&Zt(e)&&n<=t&&t<e}function ct(t,n,e,r){if(!bt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Ye(t){let n;for(n=0;t>Xt;t>>=Kt,n+=1);return n}const Rt=t=>(Kt<<BigInt(t))-Kt,kt=t=>new Uint8Array(t),ie=t=>Uint8Array.from(t);function De(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=kt(t),s=kt(t),i=0;const c=()=>{r.fill(1),s.fill(0),i=0},f=(...m)=>e(s,r,...m),o=(m=kt(0))=>{s=f(ie([0]),m),r=f(),m.length!==0&&(s=f(ie([1]),m),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let m=0;const v=[];for(;m<n;){r=f();const p=r.slice();v.push(p),m+=r.length}return D(...v)};return(m,v)=>{c(),o(m);let p;for(;!(p=v(u()));)o();return c(),p}}const We={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||xt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Bt(t,n,e={}){const r=(s,i,c)=>{const f=We[i];if(typeof f!="function")throw new Error("invalid validator function");const o=t[s];if(!(c&&o===void 0)&&!f(o,t))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+o)};for(const[s,i]of Object.entries(n))r(s,i,!1);for(const[s,i]of Object.entries(e))r(s,i,!0);return t}function se(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const i=t(e,...r);return n.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),M=BigInt(1),st=BigInt(2),Ge=BigInt(3),ve=BigInt(4),xe=BigInt(5),Be=BigInt(8);function C(t,n){const e=t%n;return e>=K?e:n+e}function Y(t,n,e){let r=t;for(;n-- >K;)r*=r,r%=e;return r}function Yt(t,n){if(t===K)throw new Error("invert: expected non-zero number");if(n<=K)throw new Error("invert: expected positive modulus, got "+n);let e=C(t,n),r=n,s=K,i=M;for(;e!==K;){const f=r/e,o=r%e,u=s-i*f;r=e,e=o,s=i,i=u}if(r!==M)throw new Error("invert: does not exist");return C(s,n)}function Se(t,n){const e=(t.ORDER+M)/ve,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function $e(t,n){const e=(t.ORDER-xe)/Be,r=t.mul(n,st),s=t.pow(r,e),i=t.mul(n,s),c=t.mul(t.mul(i,st),s),f=t.mul(i,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function Xe(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-M,e=0;for(;n%st===K;)n/=st,e++;let r=st;const s=Jt(t);for(;ce(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Se;let i=s.pow(r,n);const c=(n+M)/st;return function(o,u){if(o.is0(u))return u;if(ce(o,u)!==1)throw new Error("Cannot find square root");let d=e,m=o.mul(o.ONE,i),v=o.pow(u,n),p=o.pow(u,c);for(;!o.eql(v,o.ONE);){if(o.is0(v))return o.ZERO;let N=1,g=o.sqr(v);for(;!o.eql(g,o.ONE);)if(N++,g=o.sqr(g),N===d)throw new Error("Cannot find square root");const L=M<<BigInt(d-N-1),_=o.pow(m,L);d=N,m=o.sqr(_),v=o.mul(v,m),p=o.mul(p,_)}return p}}function Qe(t){return t%ve===Ge?Se:t%Be===xe?$e:Xe(t)}const Je=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ae(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Je.reduce((r,s)=>(r[s]="function",r),n);return Bt(t,e)}function Fe(t,n,e){if(e<K)throw new Error("invalid exponent, negatives unsupported");if(e===K)return t.ONE;if(e===M)return n;let r=t.ONE,s=n;for(;e>K;)e&M&&(r=t.mul(r,s)),s=t.sqr(s),e>>=M;return r}function Tt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,o)=>t.is0(f)?c:(r[o]=c,t.mul(c,f)),t.ONE),i=t.inv(s);return n.reduceRight((c,f,o)=>t.is0(f)?c:(r[o]=t.mul(c,r[o]),t.mul(c,f)),i),r}function ce(t,n){const e=(t.ORDER-M)/st,r=t.pow(n,e),s=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!i&&!c)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function _e(t,n){n!==void 0&&Me(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Jt(t,n,e=!1,r={}){if(t<=K)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:i}=_e(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:i,MASK:Rt(s),ZERO:K,ONE:M,create:o=>C(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return K<=o&&o<t},is0:o=>o===K,isOdd:o=>(o&M)===M,neg:o=>C(-o,t),eql:(o,u)=>o===u,sqr:o=>C(o*o,t),add:(o,u)=>C(o+u,t),sub:(o,u)=>C(o-u,t),mul:(o,u)=>C(o*u,t),pow:(o,u)=>Fe(f,o,u),div:(o,u)=>C(o*Yt(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>Yt(o,t),sqrt:r.sqrt||(o=>(c||(c=Qe(t)),c(f,o))),toBytes:o=>e?pe(o,i):ft(o,i),fromBytes:o=>{if(o.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+o.length);return e?Ee(o):$(o)},invertBatch:o=>Tt(f,o),cmov:(o,u,d)=>d?u:o});return Object.freeze(f)}function Ie(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Oe(t){const n=Ie(t);return n+Math.ceil(n/2)}function tn(t,n,e=!1){const r=t.length,s=Ie(n),i=Oe(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const c=e?Ee(t):$(t),f=C(c,n-M)+M;return e?pe(f,s):ft(f,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fe=BigInt(0),Dt=BigInt(1);function Ct(t,n){const e=n.negate();return t?e:n}function qe(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function zt(t,n){qe(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),s=2**t,i=Rt(t),c=BigInt(t);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:c}}function ae(t,n,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:c}=e;let f=Number(t&s),o=t>>c;f>r&&(f-=i,o+=Dt);const u=n*r,d=u+Math.abs(f)-1,m=f===0,v=f<0,p=n%2!==0;return{nextN:o,offset:d,isZero:m,isNeg:v,isNegF:p,offsetF:u}}function en(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function nn(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Vt=new WeakMap,Ne=new WeakMap;function Pt(t){return Ne.get(t)||1}function rn(t,n){return{constTimeNegate:Ct,hasPrecomputes(e){return Pt(e)!==1},unsafeLadder(e,r,s=t.ZERO){let i=e;for(;r>fe;)r&Dt&&(s=s.add(i)),i=i.double(),r>>=Dt;return s},precomputeWindow(e,r){const{windows:s,windowSize:i}=zt(r,n),c=[];let f=e,o=f;for(let u=0;u<s;u++){o=f,c.push(o);for(let d=1;d<i;d++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(e,r,s){let i=t.ZERO,c=t.BASE;const f=zt(e,n);for(let o=0;o<f.windows;o++){const{nextN:u,offset:d,isZero:m,isNeg:v,isNegF:p,offsetF:N}=ae(s,o,f);s=u,m?c=c.add(Ct(p,r[N])):i=i.add(Ct(v,r[d]))}return{p:i,f:c}},wNAFUnsafe(e,r,s,i=t.ZERO){const c=zt(e,n);for(let f=0;f<c.windows&&s!==fe;f++){const{nextN:o,offset:u,isZero:d,isNeg:m}=ae(s,f,c);if(s=o,!d){const v=r[u];i=i.add(m?v.negate():v)}}return i},getPrecomputes(e,r,s){let i=Vt.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&Vt.set(r,s(i))),i},wNAFCached(e,r,s){const i=Pt(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){const c=Pt(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,i)},setWindowSize(e,r){qe(r,n),Ne.set(e,r),Vt.delete(e)}}}function on(t,n,e,r){en(e,t),nn(r,n);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=Ye(BigInt(s));let o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);const u=Rt(o),d=new Array(Number(u)+1).fill(c),m=Math.floor((n.BITS-1)/o)*o;let v=c;for(let p=m;p>=0;p-=o){d.fill(c);for(let g=0;g<i;g++){const L=r[g],_=Number(L>>BigInt(p)&u);d[_]=d[_].add(e[g])}let N=c;for(let g=d.length-1,L=c;g>0;g--)L=L.add(d[g]),N=N.add(L);if(v=v.add(N),p!==0)for(let g=0;g<o;g++)v=v.double()}return v}function Re(t){return Ae(t.Fp),Bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._e(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ue(t){t.lowS!==void 0&&mt("lowS",t.lowS),t.prehash!==void 0&&mt("prehash",t.prehash)}function sn(t){const n=Re(t);Bt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class cn extends Error{constructor(n=""){super(n)}}const J={Err:cn,_tlv:{encode:(t,n)=>{const{Err:e}=J;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=At(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?At(s.length/2|128):"";return At(t)+i+s+n},decode(t,n){const{Err:e}=J;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],i=!!(s&128);let c=0;if(!i)c=s;else{const o=s&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)c=c<<8|d;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=J;if(t<G)throw new n("integer: negative integers are not allowed");let e=At(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=J;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return $(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=J,s=z("signature",t),{v:i,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,i),{v:u,l:d}=r.decode(2,o);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=J,r=n.encode(2,e.encode(t.r)),s=n.encode(2,e.encode(t.s)),i=r+s;return n.encode(48,i)}};function Mt(t,n){return yt(ft(t,n))}const G=BigInt(0),Z=BigInt(1),tt=BigInt(2),gt=BigInt(3),Wt=BigInt(4);function fn(t){const n=sn(t),{Fp:e}=n,r=Jt(n.n,n.nBitLength),s=n.toBytes||((y,a,w)=>{const b=a.toAffine();return D(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=n.fromBytes||(y=>{const a=y.subarray(1),w=e.fromBytes(a.subarray(0,e.BYTES)),b=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:w,y:b}});function c(y){const{a,b:w}=n,b=e.sqr(y),x=e.mul(b,y);return e.add(e.add(x,e.mul(y,a)),w)}function f(y,a){const w=e.sqr(a),b=c(y);return e.eql(w,b)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=e.mul(e.pow(n.a,gt),Wt),u=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,u)))throw new Error("bad curve params: a or b");function d(y){return bt(y,Z,n.n)}function m(y){const{allowedPrivateKeyLengths:a,nByteLength:w,wrapPrivateKey:b,n:x}=n;if(a&&typeof y!="bigint"){if(xt(y)&&(y=yt(y)),typeof y!="string"||!a.includes(y.length))throw new Error("invalid private key");y=y.padStart(w*2,"0")}let I;try{I=typeof y=="bigint"?y:$(z("private key",y,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof y)}return b&&(I=C(I,x)),ct("private key",I,Z,x),I}function v(y){if(!(y instanceof g))throw new Error("ProjectivePoint expected")}const p=se((y,a)=>{const{px:w,py:b,pz:x}=y;if(e.eql(x,e.ONE))return{x:w,y:b};const I=y.is0();a==null&&(a=I?e.ONE:e.inv(x));const U=e.mul(w,a),H=e.mul(b,a),B=e.mul(x,a);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:U,y:H}}),N=se(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:a,y:w}=y.toAffine();if(!e.isValid(a)||!e.isValid(w))throw new Error("bad point: x or y not FE");if(!f(a,w))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(a,w,b){if(a==null||!e.isValid(a))throw new Error("x required");if(w==null||!e.isValid(w)||e.is0(w))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");this.px=a,this.py=w,this.pz=b,Object.freeze(this)}static fromAffine(a){const{x:w,y:b}=a||{};if(!a||!e.isValid(w)||!e.isValid(b))throw new Error("invalid affine point");if(a instanceof g)throw new Error("projective point not allowed");const x=I=>e.eql(I,e.ZERO);return x(w)&&x(b)?g.ZERO:new g(w,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const w=Tt(e,a.map(b=>b.pz));return a.map((b,x)=>b.toAffine(w[x])).map(g.fromAffine)}static fromHex(a){const w=g.fromAffine(i(z("pointHex",a)));return w.assertValidity(),w}static fromPrivateKey(a){return g.BASE.multiply(m(a))}static msm(a,w){return on(g,r,a,w)}_setWindowSize(a){T.setWindowSize(this,a)}assertValidity(){N(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){v(a);const{px:w,py:b,pz:x}=this,{px:I,py:U,pz:H}=a,B=e.eql(e.mul(w,H),e.mul(I,x)),R=e.eql(e.mul(b,H),e.mul(U,x));return B&&R}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a,b:w}=n,b=e.mul(w,gt),{px:x,py:I,pz:U}=this;let H=e.ZERO,B=e.ZERO,R=e.ZERO,S=e.mul(x,x),V=e.mul(I,I),h=e.mul(U,U),l=e.mul(x,I);return l=e.add(l,l),R=e.mul(x,U),R=e.add(R,R),H=e.mul(a,R),B=e.mul(b,h),B=e.add(H,B),H=e.sub(V,B),B=e.add(V,B),B=e.mul(H,B),H=e.mul(l,H),R=e.mul(b,R),h=e.mul(a,h),l=e.sub(S,h),l=e.mul(a,l),l=e.add(l,R),R=e.add(S,S),S=e.add(R,S),S=e.add(S,h),S=e.mul(S,l),B=e.add(B,S),h=e.mul(I,U),h=e.add(h,h),S=e.mul(h,l),H=e.sub(H,S),R=e.mul(h,V),R=e.add(R,R),R=e.add(R,R),new g(H,B,R)}add(a){v(a);const{px:w,py:b,pz:x}=this,{px:I,py:U,pz:H}=a;let B=e.ZERO,R=e.ZERO,S=e.ZERO;const V=n.a,h=e.mul(n.b,gt);let l=e.mul(w,I),E=e.mul(b,U),q=e.mul(x,H),A=e.add(w,b),O=e.add(I,U);A=e.mul(A,O),O=e.add(l,E),A=e.sub(A,O),O=e.add(w,x);let k=e.add(I,H);return O=e.mul(O,k),k=e.add(l,q),O=e.sub(O,k),k=e.add(b,x),B=e.add(U,H),k=e.mul(k,B),B=e.add(E,q),k=e.sub(k,B),S=e.mul(V,O),B=e.mul(h,q),S=e.add(B,S),B=e.sub(E,S),S=e.add(E,S),R=e.mul(B,S),E=e.add(l,l),E=e.add(E,l),q=e.mul(V,q),O=e.mul(h,O),E=e.add(E,q),q=e.sub(l,q),q=e.mul(V,q),O=e.add(O,q),l=e.mul(E,O),R=e.add(R,l),l=e.mul(k,O),B=e.mul(A,B),B=e.sub(B,l),l=e.mul(A,E),S=e.mul(k,S),S=e.add(S,l),new g(B,R,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(g.ZERO)}wNAF(a){return T.wNAFCached(this,a,g.normalizeZ)}multiplyUnsafe(a){const{endo:w,n:b}=n;ct("scalar",a,G,b);const x=g.ZERO;if(a===G)return x;if(this.is0()||a===Z)return this;if(!w||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,a,g.normalizeZ);let{k1neg:I,k1:U,k2neg:H,k2:B}=w.splitScalar(a),R=x,S=x,V=this;for(;U>G||B>G;)U&Z&&(R=R.add(V)),B&Z&&(S=S.add(V)),V=V.double(),U>>=Z,B>>=Z;return I&&(R=R.negate()),H&&(S=S.negate()),S=new g(e.mul(S.px,w.beta),S.py,S.pz),R.add(S)}multiply(a){const{endo:w,n:b}=n;ct("scalar",a,Z,b);let x,I;if(w){const{k1neg:U,k1:H,k2neg:B,k2:R}=w.splitScalar(a);let{p:S,f:V}=this.wNAF(H),{p:h,f:l}=this.wNAF(R);S=T.constTimeNegate(U,S),h=T.constTimeNegate(B,h),h=new g(e.mul(h.px,w.beta),h.py,h.pz),x=S.add(h),I=V.add(l)}else{const{p:U,f:H}=this.wNAF(a);x=U,I=H}return g.normalizeZ([x,I])[0]}multiplyAndAddUnsafe(a,w,b){const x=g.BASE,I=(H,B)=>B===G||B===Z||!H.equals(x)?H.multiplyUnsafe(B):H.multiply(B),U=I(this,w).add(I(a,b));return U.is0()?void 0:U}toAffine(a){return p(this,a)}isTorsionFree(){const{h:a,isTorsionFree:w}=n;if(a===Z)return!0;if(w)return w(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:w}=n;return a===Z?this:w?w(g,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return mt("isCompressed",a),this.assertValidity(),s(g,this,a)}toHex(a=!0){return mt("isCompressed",a),yt(this.toRawBytes(a))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const{endo:L,nBitLength:_}=n,T=rn(g,L?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:m,weierstrassEquation:c,isWithinCurveOrder:d}}function an(t){const n=Re(t);return Bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function un(t){const n=an(t),{Fp:e,n:r,nByteLength:s,nBitLength:i}=n,c=e.BYTES+1,f=2*e.BYTES+1;function o(h){return C(h,r)}function u(h){return Yt(h,r)}const{ProjectivePoint:d,normPrivateKeyToScalar:m,weierstrassEquation:v,isWithinCurveOrder:p}=fn({...n,toBytes(h,l,E){const q=l.toAffine(),A=e.toBytes(q.x),O=D;return mt("isCompressed",E),E?O(Uint8Array.from([l.hasEvenY()?2:3]),A):O(Uint8Array.from([4]),A,e.toBytes(q.y))},fromBytes(h){const l=h.length,E=h[0],q=h.subarray(1);if(l===c&&(E===2||E===3)){const A=$(q);if(!bt(A,Z,e.ORDER))throw new Error("Point is not on curve");const O=v(A);let k;try{k=e.sqrt(O)}catch(W){const j=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+j)}const P=(k&Z)===Z;return(E&1)===1!==P&&(k=e.neg(k)),{x:A,y:k}}else if(l===f&&E===4){const A=e.fromBytes(q.subarray(0,e.BYTES)),O=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:A,y:O}}else{const A=c,O=f;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+O+", got "+l)}}});function N(h){const l=r>>Z;return h>l}function g(h){return N(h)?o(-h):h}const L=(h,l,E)=>$(h.slice(l,E));class _{constructor(l,E,q){ct("r",l,Z,r),ct("s",E,Z,r),this.r=l,this.s=E,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(l){const E=s;return l=z("compactSignature",l,E*2),new _(L(l,0,E),L(l,E,2*E))}static fromDER(l){const{r:E,s:q}=J.toSig(z("DER",l));return new _(E,q)}assertValidity(){}addRecoveryBit(l){return new _(this.r,this.s,l)}recoverPublicKey(l){const{r:E,s:q,recovery:A}=this,O=x(z("msgHash",l));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const k=A===2||A===3?E+n.n:E;if(k>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=A&1?"03":"02",X=d.fromHex(P+Mt(k,e.BYTES)),W=u(k),j=o(-O*W),at=o(q*W),F=d.BASE.multiplyAndAddUnsafe(X,j,at);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return It(this.toDERHex())}toDERHex(){return J.hexFromSig(this)}toCompactRawBytes(){return It(this.toCompactHex())}toCompactHex(){const l=s;return Mt(this.r,l)+Mt(this.s,l)}}const T={isValidPrivateKey(h){try{return m(h),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const h=Oe(n.n);return tn(n.randomBytes(h),n.n)},precompute(h=8,l=d.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}};function y(h,l=!0){return d.fromPrivateKey(h).toRawBytes(l)}function a(h){if(typeof h=="bigint")return!1;if(h instanceof d)return!0;const E=z("key",h).length,q=e.BYTES,A=q+1,O=2*q+1;if(!(n.allowedPrivateKeyLengths||s===A))return E===A||E===O}function w(h,l,E=!0){if(a(h)===!0)throw new Error("first arg must be private key");if(a(l)===!1)throw new Error("second arg must be public key");return d.fromHex(l).multiply(m(h)).toRawBytes(E)}const b=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const l=$(h),E=h.length*8-i;return E>0?l>>BigInt(E):l},x=n.bits2int_modN||function(h){return o(b(h))},I=Rt(i);function U(h){return ct("num < 2^"+i,h,G,I),ft(h,s)}function H(h,l,E=B){if(["recovered","canonical"].some(ot=>ot in E))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:A}=n;let{lowS:O,prehash:k,extraEntropy:P}=E;O==null&&(O=!0),h=z("msgHash",h),ue(E),k&&(h=z("prehashed msgHash",q(h)));const X=x(h),W=m(l),j=[U(W),U(X)];if(P!=null&&P!==!1){const ot=P===!0?A(e.BYTES):P;j.push(z("extraEntropy",ot))}const at=D(...j),F=X;function Ht(ot){const ut=b(ot);if(!p(ut))return;const Lt=u(ut),ht=d.BASE.multiply(ut).toAffine(),it=o(ht.x);if(it===G)return;const wt=o(Lt*o(F+it*W));if(wt===G)return;let lt=(ht.x===it?0:2)|Number(ht.y&Z),ne=wt;return O&&N(wt)&&(ne=g(wt),lt^=1),new _(it,ne,lt)}return{seed:at,k2sig:Ht}}const B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};function S(h,l,E=B){const{seed:q,k2sig:A}=H(h,l,E),O=n;return De(O.hash.outputLen,O.nByteLength,O.hmac)(q,A)}d.BASE._setWindowSize(8);function V(h,l,E,q=R){const A=h;l=z("msgHash",l),E=z("publicKey",E);const{lowS:O,prehash:k,format:P}=q;if(ue(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(P!==void 0&&P!=="compact"&&P!=="der")throw new Error("format must be compact or der");const X=typeof A=="string"||xt(A),W=!X&&!P&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!X&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,at;try{if(W&&(j=new _(A.r,A.s)),X){try{P!=="compact"&&(j=_.fromDER(A))}catch(lt){if(!(lt instanceof J.Err))throw lt}!j&&P!=="der"&&(j=_.fromCompact(A))}at=d.fromHex(E)}catch{return!1}if(!j||O&&j.hasHighS())return!1;k&&(l=n.hash(l));const{r:F,s:Ht}=j,ot=x(l),ut=u(Ht),Lt=o(ot*ut),ht=o(F*ut),it=d.BASE.multiplyAndAddUnsafe(at,Lt,ht)?.toAffine();return it?o(it.x)===F:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:w,sign:S,verify:V,ProjectivePoint:d,Signature:_,utils:T}}function ln(t,n){const e=t.ORDER;let r=G;for(let N=e-Z;N%tt===G;N/=tt)r+=Z;const s=r,i=tt<<s-Z-Z,c=i*tt,f=(e-Z)/c,o=(f-Z)/tt,u=c-Z,d=i,m=t.pow(n,f),v=t.pow(n,(f+Z)/tt);let p=(N,g)=>{let L=m,_=t.pow(g,u),T=t.sqr(_);T=t.mul(T,g);let y=t.mul(N,T);y=t.pow(y,o),y=t.mul(y,_),_=t.mul(y,g),T=t.mul(y,N);let a=t.mul(T,_);y=t.pow(a,d);let w=t.eql(y,t.ONE);_=t.mul(T,v),y=t.mul(a,L),T=t.cmov(_,T,w),a=t.cmov(y,a,w);for(let b=s;b>Z;b--){let x=b-tt;x=tt<<x-Z;let I=t.pow(a,x);const U=t.eql(I,t.ONE);_=t.mul(T,L),L=t.mul(L,L),I=t.mul(a,L),T=t.cmov(_,T,U),a=t.cmov(I,a,U)}return{isValid:w,value:T}};if(t.ORDER%Wt===gt){const N=(t.ORDER-gt)/Wt,g=t.sqrt(t.neg(n));p=(L,_)=>{let T=t.sqr(_);const y=t.mul(L,_);T=t.mul(T,y);let a=t.pow(T,N);a=t.mul(a,y);const w=t.mul(a,g),b=t.mul(t.sqr(a),_),x=t.eql(b,L);let I=t.cmov(w,a,x);return{isValid:x,value:I}}}return p}function dn(t,n){if(Ae(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=ln(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,i,c,f,o,u,d,m;s=t.sqr(r),s=t.mul(s,n.Z),i=t.sqr(s),i=t.add(i,s),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),o=t.mul(u,n.A),i=t.add(i,o),i=t.mul(i,c),u=t.mul(u,f),o=t.mul(u,n.B),i=t.add(i,o),d=t.mul(s,c);const{isValid:v,value:p}=e(i,u);m=t.mul(s,r),m=t.mul(m,p),d=t.cmov(d,c,v),m=t.cmov(m,p,v);const N=t.isOdd(r)===t.isOdd(m);m=t.cmov(t.neg(m),m,N);const g=Tt(t,[f],!0)[0];return d=t.mul(d,g),{x:d,y:m}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function hn(t){return{hash:t,hmac:(n,...e)=>me(t,n,je(...e)),randomBytes:we}}function wn(t,n){const e=r=>un({...t,...hn(r)});return{...e(n),create:e}}const gn=$;function et(t,n){if(Et(t),Et(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function mn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Et(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function yn(t,n,e,r){nt(t),nt(n),Et(e),n.length>255&&(n=r(D(Qt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:i}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=D(n,et(n.length,1)),o=et(0,i),u=et(e,2),d=new Array(c),m=r(D(o,t,u,et(0,1),f));d[0]=r(D(m,et(1,1),f));for(let p=1;p<=c;p++){const N=[mn(m,d[p-1]),et(p+1,1),f];d[p]=r(D(...N))}return D(...d).slice(0,e)}function bn(t,n,e,r,s){if(nt(t),nt(n),Et(e),n.length>255){const i=Math.ceil(2*r/8);n=s.create({dkLen:i}).update(Qt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(et(e,2)).update(n).update(et(n.length,1)).digest()}function le(t,n,e){Bt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:i,hash:c,expand:f,DST:o}=e;nt(t),Et(n);const u=typeof o=="string"?Qt(o):o,d=r.toString(2).length,m=Math.ceil((d+s)/8),v=n*i*m;let p;if(f==="xmd")p=yn(t,u,v,c);else if(f==="xof")p=bn(t,u,v,s,c);else if(f==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');const N=new Array(n);for(let g=0;g<n;g++){const L=new Array(i);for(let _=0;_<i;_++){const T=m*(_+g*i),y=p.subarray(T,T+m);L[_]=C(gn(y),r)}N[g]=L}return N}function En(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[i,c,f,o]=e.map(m=>m.reduce((v,p)=>t.add(t.mul(v,r),p))),[u,d]=Tt(t,[c,o],!0);return r=t.mul(i,u),s=t.mul(s,t.mul(f,d)),{x:r,y:s}}}function pn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(i){return t.fromAffine(n(i))}function s(i){const c=i.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(i,c){const f=le(i,2,{...e,DST:e.DST,...c}),o=r(f[0]),u=r(f[1]);return s(o.add(u))},encodeToCurve(i,c){const f=le(i,1,{...e,DST:e.encodeDST,...c});return s(r(f[0]))},mapToCurve(i){if(!Array.isArray(i))throw new Error("expected array of bigints");for(const c of i)if(typeof c!="bigint")throw new Error("expected array of bigints");return s(r(i))}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ot=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ft=BigInt(0),pt=BigInt(1),qt=BigInt(2),de=(t,n)=>(t+n/qt)/n;function Te(t){const n=St,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),u=t*t*t%n,d=u*u*t%n,m=Y(d,e,n)*d%n,v=Y(m,e,n)*d%n,p=Y(v,qt,n)*u%n,N=Y(p,s,n)*p%n,g=Y(N,i,n)*N%n,L=Y(g,f,n)*g%n,_=Y(L,o,n)*L%n,T=Y(_,f,n)*g%n,y=Y(T,e,n)*d%n,a=Y(y,c,n)*N%n,w=Y(a,r,n)*u%n,b=Y(w,qt,n);if(!rt.eql(rt.sqr(b),t))throw new Error("Cannot find square root");return b}const rt=Jt(St,void 0,void 0,{sqrt:Te}),Ut=wn({a:Ft,b:BigInt(7),Fp:rt,n:Ot,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Ot,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-pt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=de(i*t,n),o=de(-r*t,n);let u=C(t-f*e-o*s,n),d=C(-f*r-o*i,n);const m=u>c,v=d>c;if(m&&(u=n-u),v&&(d=n-d),u>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:m,k1:u,k2neg:v,k2:d}}}},_t),he={};function Nt(t,...n){let e=he[t];if(e===void 0){const r=_t(Uint8Array.from(t,s=>s.charCodeAt(0)));e=D(r,r),he[t]=e}return _t(D(e,...n))}const te=t=>t.toRawBytes(!0).slice(1),Gt=t=>ft(t,32),jt=t=>C(t,St),vt=t=>C(t,Ot),ee=(()=>Ut.ProjectivePoint)(),vn=(t,n,e)=>ee.BASE.multiplyAndAddUnsafe(t,n,e);function $t(t){let n=Ut.utils.normPrivateKeyToScalar(t),e=ee.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:vt(-n),bytes:te(e)}}function Ue(t){ct("x",t,pt,St);const n=jt(t*t),e=jt(n*t+BigInt(7));let r=Te(e);r%qt!==Ft&&(r=jt(-r));const s=new ee(t,r,pt);return s.assertValidity(),s}const dt=$;function He(...t){return vt(dt(Nt("BIP0340/challenge",...t)))}function xn(t){return $t(t).bytes}function Bn(t,n,e=we(32)){const r=z("message",t),{bytes:s,scalar:i}=$t(n),c=z("auxRand",e,32),f=Gt(i^dt(Nt("BIP0340/aux",c))),o=Nt("BIP0340/nonce",f,s,r),u=vt(dt(o));if(u===Ft)throw new Error("sign failed: k is zero");const{bytes:d,scalar:m}=$t(u),v=He(d,s,r),p=new Uint8Array(64);if(p.set(d,0),p.set(Gt(vt(m+v*i)),32),!Le(p,r,s))throw new Error("sign: Invalid signature produced");return p}function Le(t,n,e){const r=z("signature",t,64),s=z("message",n),i=z("publicKey",e,32);try{const c=Ue(dt(i)),f=dt(r.subarray(0,32));if(!bt(f,pt,St))return!1;const o=dt(r.subarray(32,64));if(!bt(o,pt,Ot))return!1;const u=He(Gt(f),te(c),s),d=vn(c,o,vt(-u));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const In=(()=>({getPublicKey:xn,sign:Bn,verify:Le,utils:{randomPrivateKey:Ut.utils.randomPrivateKey,lift_x:Ue,pointToBytes:te,numberToBytesBE:ft,bytesToNumberBE:$,taggedHash:Nt,mod:C}}))(),Sn=(()=>En(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),An=(()=>dn(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}))(),Ze=(()=>pn(Ut.ProjectivePoint,t=>{const{x:n,y:e}=An(rt.create(t[0]));return Sn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:_t}))(),On=(()=>Ze.hashToCurve)(),qn=(()=>Ze.encodeToCurve)();export{qn as encodeToCurve,On as hashToCurve,In as schnorr,Ut as secp256k1,Ze as secp256k1_hasher};
